/*
 * Copyright 2025 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package main

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"runtime"
	"strings"
)

// init sets the working directory of the program to the directory
// where this source file resides. This ensures that relative paths
// used later in the program (e.g., for output) are resolved correctly.
func init() {
	var execDir string
	_, filename, _, ok := runtime.Caller(0)
	if ok {
		execDir = filepath.Dir(filename)
	}
	err := os.Chdir(execDir)
	if err != nil {
		panic(err)
	}
	workDir, err := os.Getwd()
	if err != nil {
		panic(err)
	}
	fmt.Println(workDir)
}

func main() {
	s := bytes.NewBuffer(nil)

	// Write the file header.
	s.WriteString(`
	// Code generated by internal/mocker. DO NOT EDIT.

	package gsmock
	`)

	const (
		MaxParamCount  = 6
		MaxResultCount = 4
	)

	// Write these constants into the generated file.
	s.WriteString(fmt.Sprintf(`
	const (
		MaxParamCount  = %d
		MaxResultCount = %d
	)`, MaxParamCount, MaxResultCount))

	for i := 1; i <= MaxParamCount; i++ {
		for j := 0; j <= MaxResultCount; j++ {
			mockerName := fmt.Sprintf("Mocker%d%d", i, j)
			invokerName := fmt.Sprintf("Invoker%d%d", i, j)
			factoryName := fmt.Sprintf("Mock%d%d", i, j)

			varMockerName := fmt.Sprintf("VarMocker%d%d", i, j)
			varInvokerName := fmt.Sprintf("VarInvoker%d%d", i, j)
			varFactoryName := fmt.Sprintf("VarMock%d%d", i, j)

			// Build type parameter lists for request arguments.
			req := make([]string, i)
			funcReq := make([]string, i)
			varReq := make([]string, i)
			varFuncReq := make([]string, i)
			tmplReq := make([]string, i)
			for k := 0; k < i; k++ {
				v := "T" + fmt.Sprint(k+1)
				req[k] = v
				funcReq[k] = v
				varReq[k] = v
				varFuncReq[k] = v
				if k == i-1 {
					varReq[k] = "[]" + varReq[k]
					varFuncReq[k] = "..." + varFuncReq[k]
				}
				tmplReq[k] = v
			}

			// Build type parameter lists and identifiers for return values.
			resp := make([]string, j)
			respOnlyArg := make([]string, j)
			respWithArg := make([]string, j)
			for k := 0; k < j; k++ {
				resp[k] = "R" + fmt.Sprint(k+1)
				respOnlyArg[k] = "r" + fmt.Sprint(k+1)
				respWithArg[k] = respOnlyArg[k] + " " + resp[k]
			}

			// Build type assertions for converting []any to typed arguments.
			cvtParams := make([]string, i)
			varCvtParams := make([]string, i)
			for k := 0; k < i; k++ {
				cvtParams[k] = "params[" + fmt.Sprint(k) + "].(T" + fmt.Sprint(k+1) + ")"
				if k == i-1 {
					varCvtParams[k] = "params[" + fmt.Sprint(k) + "].([]T" + fmt.Sprint(k+1) + ")"
				} else {
					varCvtParams[k] = "params[" + fmt.Sprint(k) + "].(T" + fmt.Sprint(k+1) + ")"
				}
			}

			// Prepare template data.
			data := map[string]any{
				"mockerName":  mockerName,
				"invokerName": invokerName,
				"factoryName": factoryName,
				"tmplReq":     strings.Join(tmplReq, ", "),
				"req":         strings.Join(req, ", "),
				"funcReq":     strings.Join(funcReq, ", "),
				"resp":        strings.Join(resp, ", "),
				"respOnlyArg": strings.Join(respOnlyArg, ", "),
				"respWithArg": strings.Join(respWithArg, ", "),
				"cvtParams":   strings.Join(cvtParams, ", "),
			}

			// Execute the appropriate template for this (i, j).
			if err := getMockTemplate(j).Execute(s, data); err != nil {
				panic(fmt.Errorf("error executing template(%s): %w", mockerName, err))
			}

			// Prepare template data.
			data = map[string]any{
				"mockerName":  varMockerName,
				"invokerName": varInvokerName,
				"factoryName": varFactoryName,
				"tmplReq":     strings.Join(tmplReq, ", "),
				"req":         strings.Join(varReq, ", "),
				"funcReq":     strings.Join(varFuncReq, ", "),
				"resp":        strings.Join(resp, ", "),
				"respOnlyArg": strings.Join(respOnlyArg, ", "),
				"respWithArg": strings.Join(respWithArg, ", "),
				"cvtParams":   strings.Join(varCvtParams, ", "),
			}

			// Execute the appropriate template for this (i, j).
			if err := getMockTemplate(j).Execute(s, data); err != nil {
				panic(fmt.Errorf("error executing template(%s): %w", varMockerName, err))
			}
		}
	}

	// Format the generated code using go/format.
	b, err := format.Source(s.Bytes())
	if err != nil {
		panic(fmt.Errorf("error formatting source code: %w", err))
	}

	// Write the formatted code to the output file.
	const fileName = "../../gsmock/mocker.go"
	err = os.WriteFile(fileName, b, os.ModePerm)
	if err != nil {
		panic(fmt.Errorf("error writing file(%s): %w", fileName, err))
	}
}
