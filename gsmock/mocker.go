// Code generated by internal/mocker. DO NOT EDIT.

package gsmock

const (
	MaxParamCount  = 6
	MaxResultCount = 4
)

/******************************** Mocker10 ***********************************/

type Mocker10[T1 any] struct {
	fnHandle func(T1)
	fnWhen   func(T1) bool
	fnReturn func()
}

// Handle sets a custom function to handle requests.
func (m *Mocker10[T1]) Handle(fn func(T1)) {
	m.fnHandle = fn
}

// When sets a condition function that determines if the mock should apply.
func (m *Mocker10[T1]) When(fn func(T1) bool) *Mocker10[T1] {
	m.fnWhen = fn
	return m
}

// Return sets a function that returns predefined values.
func (m *Mocker10[T1]) Return(fn func()) {
	if m.fnWhen == nil {
		m.fnWhen = func(T1) bool { return true }
	}
	m.fnReturn = fn
}

// ReturnValue sets a return function with predefined values.
func (m *Mocker10[T1]) ReturnValue() {
	m.Return(func() {})
}

// ReturnDefault sets a return function that returns zero values for all return types.
func (m *Mocker10[T1]) ReturnDefault() {
	m.Return(func() {})
}

// Invoker10 is an Invoker implementation for Mocker10.
type Invoker10[T1 any] struct {
	*Mocker10[T1]
}

// Mode determines whether the mock operates in Handle mode or WhenReturn mode.
func (m *Invoker10[T1]) Mode() Mode {
	if m.fnHandle != nil {
		return ModeHandle
	}
	return ModeWhenReturn
}

// Handle executes the custom function if set.
func (m *Invoker10[T1]) Handle(params []any) []any {
	m.fnHandle(params[0].(T1))
	return []any{}
}

// When checks if the condition function evaluates to true.
func (m *Invoker10[T1]) When(params []any) bool {
	if m.fnWhen == nil {
		return false
	}
	return m.fnWhen(params[0].(T1))
}

// Return provides predefined response and error values.
func (m *Invoker10[T1]) Return() []any {
	m.fnReturn()
	return []any{}
}

// Mock10 creates a new Mocker10 instance.
func Mock10[T1 any](f func(T1), r *Manager) *Mocker10[T1] {
	PatchOnce(f)
	m := &Mocker10[T1]{}
	i := &Invoker10[T1]{Mocker10: m}
	r.addMocker(f, i)
	return m
}

/******************************** VarMocker10 ***********************************/

type VarMocker10[T1 any] struct {
	fnHandle func([]T1)
	fnWhen   func([]T1) bool
	fnReturn func()
}

// Handle sets a custom function to handle requests.
func (m *VarMocker10[T1]) Handle(fn func([]T1)) {
	m.fnHandle = fn
}

// When sets a condition function that determines if the mock should apply.
func (m *VarMocker10[T1]) When(fn func([]T1) bool) *VarMocker10[T1] {
	m.fnWhen = fn
	return m
}

// Return sets a function that returns predefined values.
func (m *VarMocker10[T1]) Return(fn func()) {
	if m.fnWhen == nil {
		m.fnWhen = func([]T1) bool { return true }
	}
	m.fnReturn = fn
}

// ReturnValue sets a return function with predefined values.
func (m *VarMocker10[T1]) ReturnValue() {
	m.Return(func() {})
}

// ReturnDefault sets a return function that returns zero values for all return types.
func (m *VarMocker10[T1]) ReturnDefault() {
	m.Return(func() {})
}

// VarInvoker10 is an Invoker implementation for VarMocker10.
type VarInvoker10[T1 any] struct {
	*VarMocker10[T1]
}

// Mode determines whether the mock operates in Handle mode or WhenReturn mode.
func (m *VarInvoker10[T1]) Mode() Mode {
	if m.fnHandle != nil {
		return ModeHandle
	}
	return ModeWhenReturn
}

// Handle executes the custom function if set.
func (m *VarInvoker10[T1]) Handle(params []any) []any {
	m.fnHandle(params[0].([]T1))
	return []any{}
}

// When checks if the condition function evaluates to true.
func (m *VarInvoker10[T1]) When(params []any) bool {
	if m.fnWhen == nil {
		return false
	}
	return m.fnWhen(params[0].([]T1))
}

// Return provides predefined response and error values.
func (m *VarInvoker10[T1]) Return() []any {
	m.fnReturn()
	return []any{}
}

// VarMock10 creates a new VarMocker10 instance.
func VarMock10[T1 any](f func(...T1), r *Manager) *VarMocker10[T1] {
	PatchOnce(f)
	m := &VarMocker10[T1]{}
	i := &VarInvoker10[T1]{VarMocker10: m}
	r.addMocker(f, i)
	return m
}

/******************************** Mocker11 ***********************************/

type Mocker11[T1 any, R1 any] struct {
	fnHandle func(T1) R1
	fnWhen   func(T1) bool
	fnReturn func() R1
}

// Handle sets a custom function to handle requests.
func (m *Mocker11[T1, R1]) Handle(fn func(T1) R1) {
	m.fnHandle = fn
}

// When sets a condition function that determines if the mock should apply.
func (m *Mocker11[T1, R1]) When(fn func(T1) bool) *Mocker11[T1, R1] {
	m.fnWhen = fn
	return m
}

// Return sets a function that returns predefined values.
func (m *Mocker11[T1, R1]) Return(fn func() R1) {
	if m.fnWhen == nil {
		m.fnWhen = func(T1) bool { return true }
	}
	m.fnReturn = fn
}

// ReturnValue sets a return function with predefined values.
func (m *Mocker11[T1, R1]) ReturnValue(r1 R1) {
	m.Return(func() R1 { return r1 })
}

// ReturnDefault sets a return function that returns zero values for all return types.
func (m *Mocker11[T1, R1]) ReturnDefault() {
	m.Return(func() (r1 R1) { return r1 })
}

// Invoker11 is an Invoker implementation for Mocker11.
type Invoker11[T1 any, R1 any] struct {
	*Mocker11[T1, R1]
}

// Mode determines whether the mock operates in Handle mode or WhenReturn mode.
func (m *Invoker11[T1, R1]) Mode() Mode {
	if m.fnHandle != nil {
		return ModeHandle
	}
	return ModeWhenReturn
}

// Handle executes the custom function if set.
func (m *Invoker11[T1, R1]) Handle(params []any) []any {
	r1 := m.fnHandle(params[0].(T1))
	return []any{r1}
}

// When checks if the condition function evaluates to true.
func (m *Invoker11[T1, R1]) When(params []any) bool {
	if m.fnWhen == nil {
		return false
	}
	return m.fnWhen(params[0].(T1))
}

// Return provides predefined response and error values.
func (m *Invoker11[T1, R1]) Return() []any {
	r1 := m.fnReturn()
	return []any{r1}
}

// Mock11 creates a new Mocker11 instance.
func Mock11[T1 any, R1 any](f func(T1) R1, r *Manager) *Mocker11[T1, R1] {
	PatchOnce(f)
	m := &Mocker11[T1, R1]{}
	i := &Invoker11[T1, R1]{Mocker11: m}
	r.addMocker(f, i)
	return m
}

/******************************** VarMocker11 ***********************************/

type VarMocker11[T1 any, R1 any] struct {
	fnHandle func([]T1) R1
	fnWhen   func([]T1) bool
	fnReturn func() R1
}

// Handle sets a custom function to handle requests.
func (m *VarMocker11[T1, R1]) Handle(fn func([]T1) R1) {
	m.fnHandle = fn
}

// When sets a condition function that determines if the mock should apply.
func (m *VarMocker11[T1, R1]) When(fn func([]T1) bool) *VarMocker11[T1, R1] {
	m.fnWhen = fn
	return m
}

// Return sets a function that returns predefined values.
func (m *VarMocker11[T1, R1]) Return(fn func() R1) {
	if m.fnWhen == nil {
		m.fnWhen = func([]T1) bool { return true }
	}
	m.fnReturn = fn
}

// ReturnValue sets a return function with predefined values.
func (m *VarMocker11[T1, R1]) ReturnValue(r1 R1) {
	m.Return(func() R1 { return r1 })
}

// ReturnDefault sets a return function that returns zero values for all return types.
func (m *VarMocker11[T1, R1]) ReturnDefault() {
	m.Return(func() (r1 R1) { return r1 })
}

// VarInvoker11 is an Invoker implementation for VarMocker11.
type VarInvoker11[T1 any, R1 any] struct {
	*VarMocker11[T1, R1]
}

// Mode determines whether the mock operates in Handle mode or WhenReturn mode.
func (m *VarInvoker11[T1, R1]) Mode() Mode {
	if m.fnHandle != nil {
		return ModeHandle
	}
	return ModeWhenReturn
}

// Handle executes the custom function if set.
func (m *VarInvoker11[T1, R1]) Handle(params []any) []any {
	r1 := m.fnHandle(params[0].([]T1))
	return []any{r1}
}

// When checks if the condition function evaluates to true.
func (m *VarInvoker11[T1, R1]) When(params []any) bool {
	if m.fnWhen == nil {
		return false
	}
	return m.fnWhen(params[0].([]T1))
}

// Return provides predefined response and error values.
func (m *VarInvoker11[T1, R1]) Return() []any {
	r1 := m.fnReturn()
	return []any{r1}
}

// VarMock11 creates a new VarMocker11 instance.
func VarMock11[T1 any, R1 any](f func(...T1) R1, r *Manager) *VarMocker11[T1, R1] {
	PatchOnce(f)
	m := &VarMocker11[T1, R1]{}
	i := &VarInvoker11[T1, R1]{VarMocker11: m}
	r.addMocker(f, i)
	return m
}

/******************************** Mocker12 ***********************************/

type Mocker12[T1 any, R1, R2 any] struct {
	fnHandle func(T1) (R1, R2)
	fnWhen   func(T1) bool
	fnReturn func() (R1, R2)
}

// Handle sets a custom function to handle requests.
func (m *Mocker12[T1, R1, R2]) Handle(fn func(T1) (R1, R2)) {
	m.fnHandle = fn
}

// When sets a condition function that determines if the mock should apply.
func (m *Mocker12[T1, R1, R2]) When(fn func(T1) bool) *Mocker12[T1, R1, R2] {
	m.fnWhen = fn
	return m
}

// Return sets a function that returns predefined values.
func (m *Mocker12[T1, R1, R2]) Return(fn func() (R1, R2)) {
	if m.fnWhen == nil {
		m.fnWhen = func(T1) bool { return true }
	}
	m.fnReturn = fn
}

// ReturnValue sets a return function with predefined values.
func (m *Mocker12[T1, R1, R2]) ReturnValue(r1 R1, r2 R2) {
	m.Return(func() (R1, R2) { return r1, r2 })
}

// ReturnDefault sets a return function that returns zero values for all return types.
func (m *Mocker12[T1, R1, R2]) ReturnDefault() {
	m.Return(func() (r1 R1, r2 R2) { return r1, r2 })
}

// Invoker12 is an Invoker implementation for Mocker12.
type Invoker12[T1 any, R1, R2 any] struct {
	*Mocker12[T1, R1, R2]
}

// Mode determines whether the mock operates in Handle mode or WhenReturn mode.
func (m *Invoker12[T1, R1, R2]) Mode() Mode {
	if m.fnHandle != nil {
		return ModeHandle
	}
	return ModeWhenReturn
}

// Handle executes the custom function if set.
func (m *Invoker12[T1, R1, R2]) Handle(params []any) []any {
	r1, r2 := m.fnHandle(params[0].(T1))
	return []any{r1, r2}
}

// When checks if the condition function evaluates to true.
func (m *Invoker12[T1, R1, R2]) When(params []any) bool {
	if m.fnWhen == nil {
		return false
	}
	return m.fnWhen(params[0].(T1))
}

// Return provides predefined response and error values.
func (m *Invoker12[T1, R1, R2]) Return() []any {
	r1, r2 := m.fnReturn()
	return []any{r1, r2}
}

// Mock12 creates a new Mocker12 instance.
func Mock12[T1 any, R1, R2 any](f func(T1) (R1, R2), r *Manager) *Mocker12[T1, R1, R2] {
	PatchOnce(f)
	m := &Mocker12[T1, R1, R2]{}
	i := &Invoker12[T1, R1, R2]{Mocker12: m}
	r.addMocker(f, i)
	return m
}

/******************************** VarMocker12 ***********************************/

type VarMocker12[T1 any, R1, R2 any] struct {
	fnHandle func([]T1) (R1, R2)
	fnWhen   func([]T1) bool
	fnReturn func() (R1, R2)
}

// Handle sets a custom function to handle requests.
func (m *VarMocker12[T1, R1, R2]) Handle(fn func([]T1) (R1, R2)) {
	m.fnHandle = fn
}

// When sets a condition function that determines if the mock should apply.
func (m *VarMocker12[T1, R1, R2]) When(fn func([]T1) bool) *VarMocker12[T1, R1, R2] {
	m.fnWhen = fn
	return m
}

// Return sets a function that returns predefined values.
func (m *VarMocker12[T1, R1, R2]) Return(fn func() (R1, R2)) {
	if m.fnWhen == nil {
		m.fnWhen = func([]T1) bool { return true }
	}
	m.fnReturn = fn
}

// ReturnValue sets a return function with predefined values.
func (m *VarMocker12[T1, R1, R2]) ReturnValue(r1 R1, r2 R2) {
	m.Return(func() (R1, R2) { return r1, r2 })
}

// ReturnDefault sets a return function that returns zero values for all return types.
func (m *VarMocker12[T1, R1, R2]) ReturnDefault() {
	m.Return(func() (r1 R1, r2 R2) { return r1, r2 })
}

// VarInvoker12 is an Invoker implementation for VarMocker12.
type VarInvoker12[T1 any, R1, R2 any] struct {
	*VarMocker12[T1, R1, R2]
}

// Mode determines whether the mock operates in Handle mode or WhenReturn mode.
func (m *VarInvoker12[T1, R1, R2]) Mode() Mode {
	if m.fnHandle != nil {
		return ModeHandle
	}
	return ModeWhenReturn
}

// Handle executes the custom function if set.
func (m *VarInvoker12[T1, R1, R2]) Handle(params []any) []any {
	r1, r2 := m.fnHandle(params[0].([]T1))
	return []any{r1, r2}
}

// When checks if the condition function evaluates to true.
func (m *VarInvoker12[T1, R1, R2]) When(params []any) bool {
	if m.fnWhen == nil {
		return false
	}
	return m.fnWhen(params[0].([]T1))
}

// Return provides predefined response and error values.
func (m *VarInvoker12[T1, R1, R2]) Return() []any {
	r1, r2 := m.fnReturn()
	return []any{r1, r2}
}

// VarMock12 creates a new VarMocker12 instance.
func VarMock12[T1 any, R1, R2 any](f func(...T1) (R1, R2), r *Manager) *VarMocker12[T1, R1, R2] {
	PatchOnce(f)
	m := &VarMocker12[T1, R1, R2]{}
	i := &VarInvoker12[T1, R1, R2]{VarMocker12: m}
	r.addMocker(f, i)
	return m
}

/******************************** Mocker13 ***********************************/

type Mocker13[T1 any, R1, R2, R3 any] struct {
	fnHandle func(T1) (R1, R2, R3)
	fnWhen   func(T1) bool
	fnReturn func() (R1, R2, R3)
}

// Handle sets a custom function to handle requests.
func (m *Mocker13[T1, R1, R2, R3]) Handle(fn func(T1) (R1, R2, R3)) {
	m.fnHandle = fn
}

// When sets a condition function that determines if the mock should apply.
func (m *Mocker13[T1, R1, R2, R3]) When(fn func(T1) bool) *Mocker13[T1, R1, R2, R3] {
	m.fnWhen = fn
	return m
}

// Return sets a function that returns predefined values.
func (m *Mocker13[T1, R1, R2, R3]) Return(fn func() (R1, R2, R3)) {
	if m.fnWhen == nil {
		m.fnWhen = func(T1) bool { return true }
	}
	m.fnReturn = fn
}

// ReturnValue sets a return function with predefined values.
func (m *Mocker13[T1, R1, R2, R3]) ReturnValue(r1 R1, r2 R2, r3 R3) {
	m.Return(func() (R1, R2, R3) { return r1, r2, r3 })
}

// ReturnDefault sets a return function that returns zero values for all return types.
func (m *Mocker13[T1, R1, R2, R3]) ReturnDefault() {
	m.Return(func() (r1 R1, r2 R2, r3 R3) { return r1, r2, r3 })
}

// Invoker13 is an Invoker implementation for Mocker13.
type Invoker13[T1 any, R1, R2, R3 any] struct {
	*Mocker13[T1, R1, R2, R3]
}

// Mode determines whether the mock operates in Handle mode or WhenReturn mode.
func (m *Invoker13[T1, R1, R2, R3]) Mode() Mode {
	if m.fnHandle != nil {
		return ModeHandle
	}
	return ModeWhenReturn
}

// Handle executes the custom function if set.
func (m *Invoker13[T1, R1, R2, R3]) Handle(params []any) []any {
	r1, r2, r3 := m.fnHandle(params[0].(T1))
	return []any{r1, r2, r3}
}

// When checks if the condition function evaluates to true.
func (m *Invoker13[T1, R1, R2, R3]) When(params []any) bool {
	if m.fnWhen == nil {
		return false
	}
	return m.fnWhen(params[0].(T1))
}

// Return provides predefined response and error values.
func (m *Invoker13[T1, R1, R2, R3]) Return() []any {
	r1, r2, r3 := m.fnReturn()
	return []any{r1, r2, r3}
}

// Mock13 creates a new Mocker13 instance.
func Mock13[T1 any, R1, R2, R3 any](f func(T1) (R1, R2, R3), r *Manager) *Mocker13[T1, R1, R2, R3] {
	PatchOnce(f)
	m := &Mocker13[T1, R1, R2, R3]{}
	i := &Invoker13[T1, R1, R2, R3]{Mocker13: m}
	r.addMocker(f, i)
	return m
}

/******************************** VarMocker13 ***********************************/

type VarMocker13[T1 any, R1, R2, R3 any] struct {
	fnHandle func([]T1) (R1, R2, R3)
	fnWhen   func([]T1) bool
	fnReturn func() (R1, R2, R3)
}

// Handle sets a custom function to handle requests.
func (m *VarMocker13[T1, R1, R2, R3]) Handle(fn func([]T1) (R1, R2, R3)) {
	m.fnHandle = fn
}

// When sets a condition function that determines if the mock should apply.
func (m *VarMocker13[T1, R1, R2, R3]) When(fn func([]T1) bool) *VarMocker13[T1, R1, R2, R3] {
	m.fnWhen = fn
	return m
}

// Return sets a function that returns predefined values.
func (m *VarMocker13[T1, R1, R2, R3]) Return(fn func() (R1, R2, R3)) {
	if m.fnWhen == nil {
		m.fnWhen = func([]T1) bool { return true }
	}
	m.fnReturn = fn
}

// ReturnValue sets a return function with predefined values.
func (m *VarMocker13[T1, R1, R2, R3]) ReturnValue(r1 R1, r2 R2, r3 R3) {
	m.Return(func() (R1, R2, R3) { return r1, r2, r3 })
}

// ReturnDefault sets a return function that returns zero values for all return types.
func (m *VarMocker13[T1, R1, R2, R3]) ReturnDefault() {
	m.Return(func() (r1 R1, r2 R2, r3 R3) { return r1, r2, r3 })
}

// VarInvoker13 is an Invoker implementation for VarMocker13.
type VarInvoker13[T1 any, R1, R2, R3 any] struct {
	*VarMocker13[T1, R1, R2, R3]
}

// Mode determines whether the mock operates in Handle mode or WhenReturn mode.
func (m *VarInvoker13[T1, R1, R2, R3]) Mode() Mode {
	if m.fnHandle != nil {
		return ModeHandle
	}
	return ModeWhenReturn
}

// Handle executes the custom function if set.
func (m *VarInvoker13[T1, R1, R2, R3]) Handle(params []any) []any {
	r1, r2, r3 := m.fnHandle(params[0].([]T1))
	return []any{r1, r2, r3}
}

// When checks if the condition function evaluates to true.
func (m *VarInvoker13[T1, R1, R2, R3]) When(params []any) bool {
	if m.fnWhen == nil {
		return false
	}
	return m.fnWhen(params[0].([]T1))
}

// Return provides predefined response and error values.
func (m *VarInvoker13[T1, R1, R2, R3]) Return() []any {
	r1, r2, r3 := m.fnReturn()
	return []any{r1, r2, r3}
}

// VarMock13 creates a new VarMocker13 instance.
func VarMock13[T1 any, R1, R2, R3 any](f func(...T1) (R1, R2, R3), r *Manager) *VarMocker13[T1, R1, R2, R3] {
	PatchOnce(f)
	m := &VarMocker13[T1, R1, R2, R3]{}
	i := &VarInvoker13[T1, R1, R2, R3]{VarMocker13: m}
	r.addMocker(f, i)
	return m
}

/******************************** Mocker14 ***********************************/

type Mocker14[T1 any, R1, R2, R3, R4 any] struct {
	fnHandle func(T1) (R1, R2, R3, R4)
	fnWhen   func(T1) bool
	fnReturn func() (R1, R2, R3, R4)
}

// Handle sets a custom function to handle requests.
func (m *Mocker14[T1, R1, R2, R3, R4]) Handle(fn func(T1) (R1, R2, R3, R4)) {
	m.fnHandle = fn
}

// When sets a condition function that determines if the mock should apply.
func (m *Mocker14[T1, R1, R2, R3, R4]) When(fn func(T1) bool) *Mocker14[T1, R1, R2, R3, R4] {
	m.fnWhen = fn
	return m
}

// Return sets a function that returns predefined values.
func (m *Mocker14[T1, R1, R2, R3, R4]) Return(fn func() (R1, R2, R3, R4)) {
	if m.fnWhen == nil {
		m.fnWhen = func(T1) bool { return true }
	}
	m.fnReturn = fn
}

// ReturnValue sets a return function with predefined values.
func (m *Mocker14[T1, R1, R2, R3, R4]) ReturnValue(r1 R1, r2 R2, r3 R3, r4 R4) {
	m.Return(func() (R1, R2, R3, R4) { return r1, r2, r3, r4 })
}

// ReturnDefault sets a return function that returns zero values for all return types.
func (m *Mocker14[T1, R1, R2, R3, R4]) ReturnDefault() {
	m.Return(func() (r1 R1, r2 R2, r3 R3, r4 R4) { return r1, r2, r3, r4 })
}

// Invoker14 is an Invoker implementation for Mocker14.
type Invoker14[T1 any, R1, R2, R3, R4 any] struct {
	*Mocker14[T1, R1, R2, R3, R4]
}

// Mode determines whether the mock operates in Handle mode or WhenReturn mode.
func (m *Invoker14[T1, R1, R2, R3, R4]) Mode() Mode {
	if m.fnHandle != nil {
		return ModeHandle
	}
	return ModeWhenReturn
}

// Handle executes the custom function if set.
func (m *Invoker14[T1, R1, R2, R3, R4]) Handle(params []any) []any {
	r1, r2, r3, r4 := m.fnHandle(params[0].(T1))
	return []any{r1, r2, r3, r4}
}

// When checks if the condition function evaluates to true.
func (m *Invoker14[T1, R1, R2, R3, R4]) When(params []any) bool {
	if m.fnWhen == nil {
		return false
	}
	return m.fnWhen(params[0].(T1))
}

// Return provides predefined response and error values.
func (m *Invoker14[T1, R1, R2, R3, R4]) Return() []any {
	r1, r2, r3, r4 := m.fnReturn()
	return []any{r1, r2, r3, r4}
}

// Mock14 creates a new Mocker14 instance.
func Mock14[T1 any, R1, R2, R3, R4 any](f func(T1) (R1, R2, R3, R4), r *Manager) *Mocker14[T1, R1, R2, R3, R4] {
	PatchOnce(f)
	m := &Mocker14[T1, R1, R2, R3, R4]{}
	i := &Invoker14[T1, R1, R2, R3, R4]{Mocker14: m}
	r.addMocker(f, i)
	return m
}

/******************************** VarMocker14 ***********************************/

type VarMocker14[T1 any, R1, R2, R3, R4 any] struct {
	fnHandle func([]T1) (R1, R2, R3, R4)
	fnWhen   func([]T1) bool
	fnReturn func() (R1, R2, R3, R4)
}

// Handle sets a custom function to handle requests.
func (m *VarMocker14[T1, R1, R2, R3, R4]) Handle(fn func([]T1) (R1, R2, R3, R4)) {
	m.fnHandle = fn
}

// When sets a condition function that determines if the mock should apply.
func (m *VarMocker14[T1, R1, R2, R3, R4]) When(fn func([]T1) bool) *VarMocker14[T1, R1, R2, R3, R4] {
	m.fnWhen = fn
	return m
}

// Return sets a function that returns predefined values.
func (m *VarMocker14[T1, R1, R2, R3, R4]) Return(fn func() (R1, R2, R3, R4)) {
	if m.fnWhen == nil {
		m.fnWhen = func([]T1) bool { return true }
	}
	m.fnReturn = fn
}

// ReturnValue sets a return function with predefined values.
func (m *VarMocker14[T1, R1, R2, R3, R4]) ReturnValue(r1 R1, r2 R2, r3 R3, r4 R4) {
	m.Return(func() (R1, R2, R3, R4) { return r1, r2, r3, r4 })
}

// ReturnDefault sets a return function that returns zero values for all return types.
func (m *VarMocker14[T1, R1, R2, R3, R4]) ReturnDefault() {
	m.Return(func() (r1 R1, r2 R2, r3 R3, r4 R4) { return r1, r2, r3, r4 })
}

// VarInvoker14 is an Invoker implementation for VarMocker14.
type VarInvoker14[T1 any, R1, R2, R3, R4 any] struct {
	*VarMocker14[T1, R1, R2, R3, R4]
}

// Mode determines whether the mock operates in Handle mode or WhenReturn mode.
func (m *VarInvoker14[T1, R1, R2, R3, R4]) Mode() Mode {
	if m.fnHandle != nil {
		return ModeHandle
	}
	return ModeWhenReturn
}

// Handle executes the custom function if set.
func (m *VarInvoker14[T1, R1, R2, R3, R4]) Handle(params []any) []any {
	r1, r2, r3, r4 := m.fnHandle(params[0].([]T1))
	return []any{r1, r2, r3, r4}
}

// When checks if the condition function evaluates to true.
func (m *VarInvoker14[T1, R1, R2, R3, R4]) When(params []any) bool {
	if m.fnWhen == nil {
		return false
	}
	return m.fnWhen(params[0].([]T1))
}

// Return provides predefined response and error values.
func (m *VarInvoker14[T1, R1, R2, R3, R4]) Return() []any {
	r1, r2, r3, r4 := m.fnReturn()
	return []any{r1, r2, r3, r4}
}

// VarMock14 creates a new VarMocker14 instance.
func VarMock14[T1 any, R1, R2, R3, R4 any](f func(...T1) (R1, R2, R3, R4), r *Manager) *VarMocker14[T1, R1, R2, R3, R4] {
	PatchOnce(f)
	m := &VarMocker14[T1, R1, R2, R3, R4]{}
	i := &VarInvoker14[T1, R1, R2, R3, R4]{VarMocker14: m}
	r.addMocker(f, i)
	return m
}

/******************************** Mocker20 ***********************************/

type Mocker20[T1, T2 any] struct {
	fnHandle func(T1, T2)
	fnWhen   func(T1, T2) bool
	fnReturn func()
}

// Handle sets a custom function to handle requests.
func (m *Mocker20[T1, T2]) Handle(fn func(T1, T2)) {
	m.fnHandle = fn
}

// When sets a condition function that determines if the mock should apply.
func (m *Mocker20[T1, T2]) When(fn func(T1, T2) bool) *Mocker20[T1, T2] {
	m.fnWhen = fn
	return m
}

// Return sets a function that returns predefined values.
func (m *Mocker20[T1, T2]) Return(fn func()) {
	if m.fnWhen == nil {
		m.fnWhen = func(T1, T2) bool { return true }
	}
	m.fnReturn = fn
}

// ReturnValue sets a return function with predefined values.
func (m *Mocker20[T1, T2]) ReturnValue() {
	m.Return(func() {})
}

// ReturnDefault sets a return function that returns zero values for all return types.
func (m *Mocker20[T1, T2]) ReturnDefault() {
	m.Return(func() {})
}

// Invoker20 is an Invoker implementation for Mocker20.
type Invoker20[T1, T2 any] struct {
	*Mocker20[T1, T2]
}

// Mode determines whether the mock operates in Handle mode or WhenReturn mode.
func (m *Invoker20[T1, T2]) Mode() Mode {
	if m.fnHandle != nil {
		return ModeHandle
	}
	return ModeWhenReturn
}

// Handle executes the custom function if set.
func (m *Invoker20[T1, T2]) Handle(params []any) []any {
	m.fnHandle(params[0].(T1), params[1].(T2))
	return []any{}
}

// When checks if the condition function evaluates to true.
func (m *Invoker20[T1, T2]) When(params []any) bool {
	if m.fnWhen == nil {
		return false
	}
	return m.fnWhen(params[0].(T1), params[1].(T2))
}

// Return provides predefined response and error values.
func (m *Invoker20[T1, T2]) Return() []any {
	m.fnReturn()
	return []any{}
}

// Mock20 creates a new Mocker20 instance.
func Mock20[T1, T2 any](f func(T1, T2), r *Manager) *Mocker20[T1, T2] {
	PatchOnce(f)
	m := &Mocker20[T1, T2]{}
	i := &Invoker20[T1, T2]{Mocker20: m}
	r.addMocker(f, i)
	return m
}

/******************************** VarMocker20 ***********************************/

type VarMocker20[T1, T2 any] struct {
	fnHandle func(T1, []T2)
	fnWhen   func(T1, []T2) bool
	fnReturn func()
}

// Handle sets a custom function to handle requests.
func (m *VarMocker20[T1, T2]) Handle(fn func(T1, []T2)) {
	m.fnHandle = fn
}

// When sets a condition function that determines if the mock should apply.
func (m *VarMocker20[T1, T2]) When(fn func(T1, []T2) bool) *VarMocker20[T1, T2] {
	m.fnWhen = fn
	return m
}

// Return sets a function that returns predefined values.
func (m *VarMocker20[T1, T2]) Return(fn func()) {
	if m.fnWhen == nil {
		m.fnWhen = func(T1, []T2) bool { return true }
	}
	m.fnReturn = fn
}

// ReturnValue sets a return function with predefined values.
func (m *VarMocker20[T1, T2]) ReturnValue() {
	m.Return(func() {})
}

// ReturnDefault sets a return function that returns zero values for all return types.
func (m *VarMocker20[T1, T2]) ReturnDefault() {
	m.Return(func() {})
}

// VarInvoker20 is an Invoker implementation for VarMocker20.
type VarInvoker20[T1, T2 any] struct {
	*VarMocker20[T1, T2]
}

// Mode determines whether the mock operates in Handle mode or WhenReturn mode.
func (m *VarInvoker20[T1, T2]) Mode() Mode {
	if m.fnHandle != nil {
		return ModeHandle
	}
	return ModeWhenReturn
}

// Handle executes the custom function if set.
func (m *VarInvoker20[T1, T2]) Handle(params []any) []any {
	m.fnHandle(params[0].(T1), params[1].([]T2))
	return []any{}
}

// When checks if the condition function evaluates to true.
func (m *VarInvoker20[T1, T2]) When(params []any) bool {
	if m.fnWhen == nil {
		return false
	}
	return m.fnWhen(params[0].(T1), params[1].([]T2))
}

// Return provides predefined response and error values.
func (m *VarInvoker20[T1, T2]) Return() []any {
	m.fnReturn()
	return []any{}
}

// VarMock20 creates a new VarMocker20 instance.
func VarMock20[T1, T2 any](f func(T1, ...T2), r *Manager) *VarMocker20[T1, T2] {
	PatchOnce(f)
	m := &VarMocker20[T1, T2]{}
	i := &VarInvoker20[T1, T2]{VarMocker20: m}
	r.addMocker(f, i)
	return m
}

/******************************** Mocker21 ***********************************/

type Mocker21[T1, T2 any, R1 any] struct {
	fnHandle func(T1, T2) R1
	fnWhen   func(T1, T2) bool
	fnReturn func() R1
}

// Handle sets a custom function to handle requests.
func (m *Mocker21[T1, T2, R1]) Handle(fn func(T1, T2) R1) {
	m.fnHandle = fn
}

// When sets a condition function that determines if the mock should apply.
func (m *Mocker21[T1, T2, R1]) When(fn func(T1, T2) bool) *Mocker21[T1, T2, R1] {
	m.fnWhen = fn
	return m
}

// Return sets a function that returns predefined values.
func (m *Mocker21[T1, T2, R1]) Return(fn func() R1) {
	if m.fnWhen == nil {
		m.fnWhen = func(T1, T2) bool { return true }
	}
	m.fnReturn = fn
}

// ReturnValue sets a return function with predefined values.
func (m *Mocker21[T1, T2, R1]) ReturnValue(r1 R1) {
	m.Return(func() R1 { return r1 })
}

// ReturnDefault sets a return function that returns zero values for all return types.
func (m *Mocker21[T1, T2, R1]) ReturnDefault() {
	m.Return(func() (r1 R1) { return r1 })
}

// Invoker21 is an Invoker implementation for Mocker21.
type Invoker21[T1, T2 any, R1 any] struct {
	*Mocker21[T1, T2, R1]
}

// Mode determines whether the mock operates in Handle mode or WhenReturn mode.
func (m *Invoker21[T1, T2, R1]) Mode() Mode {
	if m.fnHandle != nil {
		return ModeHandle
	}
	return ModeWhenReturn
}

// Handle executes the custom function if set.
func (m *Invoker21[T1, T2, R1]) Handle(params []any) []any {
	r1 := m.fnHandle(params[0].(T1), params[1].(T2))
	return []any{r1}
}

// When checks if the condition function evaluates to true.
func (m *Invoker21[T1, T2, R1]) When(params []any) bool {
	if m.fnWhen == nil {
		return false
	}
	return m.fnWhen(params[0].(T1), params[1].(T2))
}

// Return provides predefined response and error values.
func (m *Invoker21[T1, T2, R1]) Return() []any {
	r1 := m.fnReturn()
	return []any{r1}
}

// Mock21 creates a new Mocker21 instance.
func Mock21[T1, T2 any, R1 any](f func(T1, T2) R1, r *Manager) *Mocker21[T1, T2, R1] {
	PatchOnce(f)
	m := &Mocker21[T1, T2, R1]{}
	i := &Invoker21[T1, T2, R1]{Mocker21: m}
	r.addMocker(f, i)
	return m
}

/******************************** VarMocker21 ***********************************/

type VarMocker21[T1, T2 any, R1 any] struct {
	fnHandle func(T1, []T2) R1
	fnWhen   func(T1, []T2) bool
	fnReturn func() R1
}

// Handle sets a custom function to handle requests.
func (m *VarMocker21[T1, T2, R1]) Handle(fn func(T1, []T2) R1) {
	m.fnHandle = fn
}

// When sets a condition function that determines if the mock should apply.
func (m *VarMocker21[T1, T2, R1]) When(fn func(T1, []T2) bool) *VarMocker21[T1, T2, R1] {
	m.fnWhen = fn
	return m
}

// Return sets a function that returns predefined values.
func (m *VarMocker21[T1, T2, R1]) Return(fn func() R1) {
	if m.fnWhen == nil {
		m.fnWhen = func(T1, []T2) bool { return true }
	}
	m.fnReturn = fn
}

// ReturnValue sets a return function with predefined values.
func (m *VarMocker21[T1, T2, R1]) ReturnValue(r1 R1) {
	m.Return(func() R1 { return r1 })
}

// ReturnDefault sets a return function that returns zero values for all return types.
func (m *VarMocker21[T1, T2, R1]) ReturnDefault() {
	m.Return(func() (r1 R1) { return r1 })
}

// VarInvoker21 is an Invoker implementation for VarMocker21.
type VarInvoker21[T1, T2 any, R1 any] struct {
	*VarMocker21[T1, T2, R1]
}

// Mode determines whether the mock operates in Handle mode or WhenReturn mode.
func (m *VarInvoker21[T1, T2, R1]) Mode() Mode {
	if m.fnHandle != nil {
		return ModeHandle
	}
	return ModeWhenReturn
}

// Handle executes the custom function if set.
func (m *VarInvoker21[T1, T2, R1]) Handle(params []any) []any {
	r1 := m.fnHandle(params[0].(T1), params[1].([]T2))
	return []any{r1}
}

// When checks if the condition function evaluates to true.
func (m *VarInvoker21[T1, T2, R1]) When(params []any) bool {
	if m.fnWhen == nil {
		return false
	}
	return m.fnWhen(params[0].(T1), params[1].([]T2))
}

// Return provides predefined response and error values.
func (m *VarInvoker21[T1, T2, R1]) Return() []any {
	r1 := m.fnReturn()
	return []any{r1}
}

// VarMock21 creates a new VarMocker21 instance.
func VarMock21[T1, T2 any, R1 any](f func(T1, ...T2) R1, r *Manager) *VarMocker21[T1, T2, R1] {
	PatchOnce(f)
	m := &VarMocker21[T1, T2, R1]{}
	i := &VarInvoker21[T1, T2, R1]{VarMocker21: m}
	r.addMocker(f, i)
	return m
}

/******************************** Mocker22 ***********************************/

type Mocker22[T1, T2 any, R1, R2 any] struct {
	fnHandle func(T1, T2) (R1, R2)
	fnWhen   func(T1, T2) bool
	fnReturn func() (R1, R2)
}

// Handle sets a custom function to handle requests.
func (m *Mocker22[T1, T2, R1, R2]) Handle(fn func(T1, T2) (R1, R2)) {
	m.fnHandle = fn
}

// When sets a condition function that determines if the mock should apply.
func (m *Mocker22[T1, T2, R1, R2]) When(fn func(T1, T2) bool) *Mocker22[T1, T2, R1, R2] {
	m.fnWhen = fn
	return m
}

// Return sets a function that returns predefined values.
func (m *Mocker22[T1, T2, R1, R2]) Return(fn func() (R1, R2)) {
	if m.fnWhen == nil {
		m.fnWhen = func(T1, T2) bool { return true }
	}
	m.fnReturn = fn
}

// ReturnValue sets a return function with predefined values.
func (m *Mocker22[T1, T2, R1, R2]) ReturnValue(r1 R1, r2 R2) {
	m.Return(func() (R1, R2) { return r1, r2 })
}

// ReturnDefault sets a return function that returns zero values for all return types.
func (m *Mocker22[T1, T2, R1, R2]) ReturnDefault() {
	m.Return(func() (r1 R1, r2 R2) { return r1, r2 })
}

// Invoker22 is an Invoker implementation for Mocker22.
type Invoker22[T1, T2 any, R1, R2 any] struct {
	*Mocker22[T1, T2, R1, R2]
}

// Mode determines whether the mock operates in Handle mode or WhenReturn mode.
func (m *Invoker22[T1, T2, R1, R2]) Mode() Mode {
	if m.fnHandle != nil {
		return ModeHandle
	}
	return ModeWhenReturn
}

// Handle executes the custom function if set.
func (m *Invoker22[T1, T2, R1, R2]) Handle(params []any) []any {
	r1, r2 := m.fnHandle(params[0].(T1), params[1].(T2))
	return []any{r1, r2}
}

// When checks if the condition function evaluates to true.
func (m *Invoker22[T1, T2, R1, R2]) When(params []any) bool {
	if m.fnWhen == nil {
		return false
	}
	return m.fnWhen(params[0].(T1), params[1].(T2))
}

// Return provides predefined response and error values.
func (m *Invoker22[T1, T2, R1, R2]) Return() []any {
	r1, r2 := m.fnReturn()
	return []any{r1, r2}
}

// Mock22 creates a new Mocker22 instance.
func Mock22[T1, T2 any, R1, R2 any](f func(T1, T2) (R1, R2), r *Manager) *Mocker22[T1, T2, R1, R2] {
	PatchOnce(f)
	m := &Mocker22[T1, T2, R1, R2]{}
	i := &Invoker22[T1, T2, R1, R2]{Mocker22: m}
	r.addMocker(f, i)
	return m
}

/******************************** VarMocker22 ***********************************/

type VarMocker22[T1, T2 any, R1, R2 any] struct {
	fnHandle func(T1, []T2) (R1, R2)
	fnWhen   func(T1, []T2) bool
	fnReturn func() (R1, R2)
}

// Handle sets a custom function to handle requests.
func (m *VarMocker22[T1, T2, R1, R2]) Handle(fn func(T1, []T2) (R1, R2)) {
	m.fnHandle = fn
}

// When sets a condition function that determines if the mock should apply.
func (m *VarMocker22[T1, T2, R1, R2]) When(fn func(T1, []T2) bool) *VarMocker22[T1, T2, R1, R2] {
	m.fnWhen = fn
	return m
}

// Return sets a function that returns predefined values.
func (m *VarMocker22[T1, T2, R1, R2]) Return(fn func() (R1, R2)) {
	if m.fnWhen == nil {
		m.fnWhen = func(T1, []T2) bool { return true }
	}
	m.fnReturn = fn
}

// ReturnValue sets a return function with predefined values.
func (m *VarMocker22[T1, T2, R1, R2]) ReturnValue(r1 R1, r2 R2) {
	m.Return(func() (R1, R2) { return r1, r2 })
}

// ReturnDefault sets a return function that returns zero values for all return types.
func (m *VarMocker22[T1, T2, R1, R2]) ReturnDefault() {
	m.Return(func() (r1 R1, r2 R2) { return r1, r2 })
}

// VarInvoker22 is an Invoker implementation for VarMocker22.
type VarInvoker22[T1, T2 any, R1, R2 any] struct {
	*VarMocker22[T1, T2, R1, R2]
}

// Mode determines whether the mock operates in Handle mode or WhenReturn mode.
func (m *VarInvoker22[T1, T2, R1, R2]) Mode() Mode {
	if m.fnHandle != nil {
		return ModeHandle
	}
	return ModeWhenReturn
}

// Handle executes the custom function if set.
func (m *VarInvoker22[T1, T2, R1, R2]) Handle(params []any) []any {
	r1, r2 := m.fnHandle(params[0].(T1), params[1].([]T2))
	return []any{r1, r2}
}

// When checks if the condition function evaluates to true.
func (m *VarInvoker22[T1, T2, R1, R2]) When(params []any) bool {
	if m.fnWhen == nil {
		return false
	}
	return m.fnWhen(params[0].(T1), params[1].([]T2))
}

// Return provides predefined response and error values.
func (m *VarInvoker22[T1, T2, R1, R2]) Return() []any {
	r1, r2 := m.fnReturn()
	return []any{r1, r2}
}

// VarMock22 creates a new VarMocker22 instance.
func VarMock22[T1, T2 any, R1, R2 any](f func(T1, ...T2) (R1, R2), r *Manager) *VarMocker22[T1, T2, R1, R2] {
	PatchOnce(f)
	m := &VarMocker22[T1, T2, R1, R2]{}
	i := &VarInvoker22[T1, T2, R1, R2]{VarMocker22: m}
	r.addMocker(f, i)
	return m
}

/******************************** Mocker23 ***********************************/

type Mocker23[T1, T2 any, R1, R2, R3 any] struct {
	fnHandle func(T1, T2) (R1, R2, R3)
	fnWhen   func(T1, T2) bool
	fnReturn func() (R1, R2, R3)
}

// Handle sets a custom function to handle requests.
func (m *Mocker23[T1, T2, R1, R2, R3]) Handle(fn func(T1, T2) (R1, R2, R3)) {
	m.fnHandle = fn
}

// When sets a condition function that determines if the mock should apply.
func (m *Mocker23[T1, T2, R1, R2, R3]) When(fn func(T1, T2) bool) *Mocker23[T1, T2, R1, R2, R3] {
	m.fnWhen = fn
	return m
}

// Return sets a function that returns predefined values.
func (m *Mocker23[T1, T2, R1, R2, R3]) Return(fn func() (R1, R2, R3)) {
	if m.fnWhen == nil {
		m.fnWhen = func(T1, T2) bool { return true }
	}
	m.fnReturn = fn
}

// ReturnValue sets a return function with predefined values.
func (m *Mocker23[T1, T2, R1, R2, R3]) ReturnValue(r1 R1, r2 R2, r3 R3) {
	m.Return(func() (R1, R2, R3) { return r1, r2, r3 })
}

// ReturnDefault sets a return function that returns zero values for all return types.
func (m *Mocker23[T1, T2, R1, R2, R3]) ReturnDefault() {
	m.Return(func() (r1 R1, r2 R2, r3 R3) { return r1, r2, r3 })
}

// Invoker23 is an Invoker implementation for Mocker23.
type Invoker23[T1, T2 any, R1, R2, R3 any] struct {
	*Mocker23[T1, T2, R1, R2, R3]
}

// Mode determines whether the mock operates in Handle mode or WhenReturn mode.
func (m *Invoker23[T1, T2, R1, R2, R3]) Mode() Mode {
	if m.fnHandle != nil {
		return ModeHandle
	}
	return ModeWhenReturn
}

// Handle executes the custom function if set.
func (m *Invoker23[T1, T2, R1, R2, R3]) Handle(params []any) []any {
	r1, r2, r3 := m.fnHandle(params[0].(T1), params[1].(T2))
	return []any{r1, r2, r3}
}

// When checks if the condition function evaluates to true.
func (m *Invoker23[T1, T2, R1, R2, R3]) When(params []any) bool {
	if m.fnWhen == nil {
		return false
	}
	return m.fnWhen(params[0].(T1), params[1].(T2))
}

// Return provides predefined response and error values.
func (m *Invoker23[T1, T2, R1, R2, R3]) Return() []any {
	r1, r2, r3 := m.fnReturn()
	return []any{r1, r2, r3}
}

// Mock23 creates a new Mocker23 instance.
func Mock23[T1, T2 any, R1, R2, R3 any](f func(T1, T2) (R1, R2, R3), r *Manager) *Mocker23[T1, T2, R1, R2, R3] {
	PatchOnce(f)
	m := &Mocker23[T1, T2, R1, R2, R3]{}
	i := &Invoker23[T1, T2, R1, R2, R3]{Mocker23: m}
	r.addMocker(f, i)
	return m
}

/******************************** VarMocker23 ***********************************/

type VarMocker23[T1, T2 any, R1, R2, R3 any] struct {
	fnHandle func(T1, []T2) (R1, R2, R3)
	fnWhen   func(T1, []T2) bool
	fnReturn func() (R1, R2, R3)
}

// Handle sets a custom function to handle requests.
func (m *VarMocker23[T1, T2, R1, R2, R3]) Handle(fn func(T1, []T2) (R1, R2, R3)) {
	m.fnHandle = fn
}

// When sets a condition function that determines if the mock should apply.
func (m *VarMocker23[T1, T2, R1, R2, R3]) When(fn func(T1, []T2) bool) *VarMocker23[T1, T2, R1, R2, R3] {
	m.fnWhen = fn
	return m
}

// Return sets a function that returns predefined values.
func (m *VarMocker23[T1, T2, R1, R2, R3]) Return(fn func() (R1, R2, R3)) {
	if m.fnWhen == nil {
		m.fnWhen = func(T1, []T2) bool { return true }
	}
	m.fnReturn = fn
}

// ReturnValue sets a return function with predefined values.
func (m *VarMocker23[T1, T2, R1, R2, R3]) ReturnValue(r1 R1, r2 R2, r3 R3) {
	m.Return(func() (R1, R2, R3) { return r1, r2, r3 })
}

// ReturnDefault sets a return function that returns zero values for all return types.
func (m *VarMocker23[T1, T2, R1, R2, R3]) ReturnDefault() {
	m.Return(func() (r1 R1, r2 R2, r3 R3) { return r1, r2, r3 })
}

// VarInvoker23 is an Invoker implementation for VarMocker23.
type VarInvoker23[T1, T2 any, R1, R2, R3 any] struct {
	*VarMocker23[T1, T2, R1, R2, R3]
}

// Mode determines whether the mock operates in Handle mode or WhenReturn mode.
func (m *VarInvoker23[T1, T2, R1, R2, R3]) Mode() Mode {
	if m.fnHandle != nil {
		return ModeHandle
	}
	return ModeWhenReturn
}

// Handle executes the custom function if set.
func (m *VarInvoker23[T1, T2, R1, R2, R3]) Handle(params []any) []any {
	r1, r2, r3 := m.fnHandle(params[0].(T1), params[1].([]T2))
	return []any{r1, r2, r3}
}

// When checks if the condition function evaluates to true.
func (m *VarInvoker23[T1, T2, R1, R2, R3]) When(params []any) bool {
	if m.fnWhen == nil {
		return false
	}
	return m.fnWhen(params[0].(T1), params[1].([]T2))
}

// Return provides predefined response and error values.
func (m *VarInvoker23[T1, T2, R1, R2, R3]) Return() []any {
	r1, r2, r3 := m.fnReturn()
	return []any{r1, r2, r3}
}

// VarMock23 creates a new VarMocker23 instance.
func VarMock23[T1, T2 any, R1, R2, R3 any](f func(T1, ...T2) (R1, R2, R3), r *Manager) *VarMocker23[T1, T2, R1, R2, R3] {
	PatchOnce(f)
	m := &VarMocker23[T1, T2, R1, R2, R3]{}
	i := &VarInvoker23[T1, T2, R1, R2, R3]{VarMocker23: m}
	r.addMocker(f, i)
	return m
}

/******************************** Mocker24 ***********************************/

type Mocker24[T1, T2 any, R1, R2, R3, R4 any] struct {
	fnHandle func(T1, T2) (R1, R2, R3, R4)
	fnWhen   func(T1, T2) bool
	fnReturn func() (R1, R2, R3, R4)
}

// Handle sets a custom function to handle requests.
func (m *Mocker24[T1, T2, R1, R2, R3, R4]) Handle(fn func(T1, T2) (R1, R2, R3, R4)) {
	m.fnHandle = fn
}

// When sets a condition function that determines if the mock should apply.
func (m *Mocker24[T1, T2, R1, R2, R3, R4]) When(fn func(T1, T2) bool) *Mocker24[T1, T2, R1, R2, R3, R4] {
	m.fnWhen = fn
	return m
}

// Return sets a function that returns predefined values.
func (m *Mocker24[T1, T2, R1, R2, R3, R4]) Return(fn func() (R1, R2, R3, R4)) {
	if m.fnWhen == nil {
		m.fnWhen = func(T1, T2) bool { return true }
	}
	m.fnReturn = fn
}

// ReturnValue sets a return function with predefined values.
func (m *Mocker24[T1, T2, R1, R2, R3, R4]) ReturnValue(r1 R1, r2 R2, r3 R3, r4 R4) {
	m.Return(func() (R1, R2, R3, R4) { return r1, r2, r3, r4 })
}

// ReturnDefault sets a return function that returns zero values for all return types.
func (m *Mocker24[T1, T2, R1, R2, R3, R4]) ReturnDefault() {
	m.Return(func() (r1 R1, r2 R2, r3 R3, r4 R4) { return r1, r2, r3, r4 })
}

// Invoker24 is an Invoker implementation for Mocker24.
type Invoker24[T1, T2 any, R1, R2, R3, R4 any] struct {
	*Mocker24[T1, T2, R1, R2, R3, R4]
}

// Mode determines whether the mock operates in Handle mode or WhenReturn mode.
func (m *Invoker24[T1, T2, R1, R2, R3, R4]) Mode() Mode {
	if m.fnHandle != nil {
		return ModeHandle
	}
	return ModeWhenReturn
}

// Handle executes the custom function if set.
func (m *Invoker24[T1, T2, R1, R2, R3, R4]) Handle(params []any) []any {
	r1, r2, r3, r4 := m.fnHandle(params[0].(T1), params[1].(T2))
	return []any{r1, r2, r3, r4}
}

// When checks if the condition function evaluates to true.
func (m *Invoker24[T1, T2, R1, R2, R3, R4]) When(params []any) bool {
	if m.fnWhen == nil {
		return false
	}
	return m.fnWhen(params[0].(T1), params[1].(T2))
}

// Return provides predefined response and error values.
func (m *Invoker24[T1, T2, R1, R2, R3, R4]) Return() []any {
	r1, r2, r3, r4 := m.fnReturn()
	return []any{r1, r2, r3, r4}
}

// Mock24 creates a new Mocker24 instance.
func Mock24[T1, T2 any, R1, R2, R3, R4 any](f func(T1, T2) (R1, R2, R3, R4), r *Manager) *Mocker24[T1, T2, R1, R2, R3, R4] {
	PatchOnce(f)
	m := &Mocker24[T1, T2, R1, R2, R3, R4]{}
	i := &Invoker24[T1, T2, R1, R2, R3, R4]{Mocker24: m}
	r.addMocker(f, i)
	return m
}

/******************************** VarMocker24 ***********************************/

type VarMocker24[T1, T2 any, R1, R2, R3, R4 any] struct {
	fnHandle func(T1, []T2) (R1, R2, R3, R4)
	fnWhen   func(T1, []T2) bool
	fnReturn func() (R1, R2, R3, R4)
}

// Handle sets a custom function to handle requests.
func (m *VarMocker24[T1, T2, R1, R2, R3, R4]) Handle(fn func(T1, []T2) (R1, R2, R3, R4)) {
	m.fnHandle = fn
}

// When sets a condition function that determines if the mock should apply.
func (m *VarMocker24[T1, T2, R1, R2, R3, R4]) When(fn func(T1, []T2) bool) *VarMocker24[T1, T2, R1, R2, R3, R4] {
	m.fnWhen = fn
	return m
}

// Return sets a function that returns predefined values.
func (m *VarMocker24[T1, T2, R1, R2, R3, R4]) Return(fn func() (R1, R2, R3, R4)) {
	if m.fnWhen == nil {
		m.fnWhen = func(T1, []T2) bool { return true }
	}
	m.fnReturn = fn
}

// ReturnValue sets a return function with predefined values.
func (m *VarMocker24[T1, T2, R1, R2, R3, R4]) ReturnValue(r1 R1, r2 R2, r3 R3, r4 R4) {
	m.Return(func() (R1, R2, R3, R4) { return r1, r2, r3, r4 })
}

// ReturnDefault sets a return function that returns zero values for all return types.
func (m *VarMocker24[T1, T2, R1, R2, R3, R4]) ReturnDefault() {
	m.Return(func() (r1 R1, r2 R2, r3 R3, r4 R4) { return r1, r2, r3, r4 })
}

// VarInvoker24 is an Invoker implementation for VarMocker24.
type VarInvoker24[T1, T2 any, R1, R2, R3, R4 any] struct {
	*VarMocker24[T1, T2, R1, R2, R3, R4]
}

// Mode determines whether the mock operates in Handle mode or WhenReturn mode.
func (m *VarInvoker24[T1, T2, R1, R2, R3, R4]) Mode() Mode {
	if m.fnHandle != nil {
		return ModeHandle
	}
	return ModeWhenReturn
}

// Handle executes the custom function if set.
func (m *VarInvoker24[T1, T2, R1, R2, R3, R4]) Handle(params []any) []any {
	r1, r2, r3, r4 := m.fnHandle(params[0].(T1), params[1].([]T2))
	return []any{r1, r2, r3, r4}
}

// When checks if the condition function evaluates to true.
func (m *VarInvoker24[T1, T2, R1, R2, R3, R4]) When(params []any) bool {
	if m.fnWhen == nil {
		return false
	}
	return m.fnWhen(params[0].(T1), params[1].([]T2))
}

// Return provides predefined response and error values.
func (m *VarInvoker24[T1, T2, R1, R2, R3, R4]) Return() []any {
	r1, r2, r3, r4 := m.fnReturn()
	return []any{r1, r2, r3, r4}
}

// VarMock24 creates a new VarMocker24 instance.
func VarMock24[T1, T2 any, R1, R2, R3, R4 any](f func(T1, ...T2) (R1, R2, R3, R4), r *Manager) *VarMocker24[T1, T2, R1, R2, R3, R4] {
	PatchOnce(f)
	m := &VarMocker24[T1, T2, R1, R2, R3, R4]{}
	i := &VarInvoker24[T1, T2, R1, R2, R3, R4]{VarMocker24: m}
	r.addMocker(f, i)
	return m
}

/******************************** Mocker30 ***********************************/

type Mocker30[T1, T2, T3 any] struct {
	fnHandle func(T1, T2, T3)
	fnWhen   func(T1, T2, T3) bool
	fnReturn func()
}

// Handle sets a custom function to handle requests.
func (m *Mocker30[T1, T2, T3]) Handle(fn func(T1, T2, T3)) {
	m.fnHandle = fn
}

// When sets a condition function that determines if the mock should apply.
func (m *Mocker30[T1, T2, T3]) When(fn func(T1, T2, T3) bool) *Mocker30[T1, T2, T3] {
	m.fnWhen = fn
	return m
}

// Return sets a function that returns predefined values.
func (m *Mocker30[T1, T2, T3]) Return(fn func()) {
	if m.fnWhen == nil {
		m.fnWhen = func(T1, T2, T3) bool { return true }
	}
	m.fnReturn = fn
}

// ReturnValue sets a return function with predefined values.
func (m *Mocker30[T1, T2, T3]) ReturnValue() {
	m.Return(func() {})
}

// ReturnDefault sets a return function that returns zero values for all return types.
func (m *Mocker30[T1, T2, T3]) ReturnDefault() {
	m.Return(func() {})
}

// Invoker30 is an Invoker implementation for Mocker30.
type Invoker30[T1, T2, T3 any] struct {
	*Mocker30[T1, T2, T3]
}

// Mode determines whether the mock operates in Handle mode or WhenReturn mode.
func (m *Invoker30[T1, T2, T3]) Mode() Mode {
	if m.fnHandle != nil {
		return ModeHandle
	}
	return ModeWhenReturn
}

// Handle executes the custom function if set.
func (m *Invoker30[T1, T2, T3]) Handle(params []any) []any {
	m.fnHandle(params[0].(T1), params[1].(T2), params[2].(T3))
	return []any{}
}

// When checks if the condition function evaluates to true.
func (m *Invoker30[T1, T2, T3]) When(params []any) bool {
	if m.fnWhen == nil {
		return false
	}
	return m.fnWhen(params[0].(T1), params[1].(T2), params[2].(T3))
}

// Return provides predefined response and error values.
func (m *Invoker30[T1, T2, T3]) Return() []any {
	m.fnReturn()
	return []any{}
}

// Mock30 creates a new Mocker30 instance.
func Mock30[T1, T2, T3 any](f func(T1, T2, T3), r *Manager) *Mocker30[T1, T2, T3] {
	PatchOnce(f)
	m := &Mocker30[T1, T2, T3]{}
	i := &Invoker30[T1, T2, T3]{Mocker30: m}
	r.addMocker(f, i)
	return m
}

/******************************** VarMocker30 ***********************************/

type VarMocker30[T1, T2, T3 any] struct {
	fnHandle func(T1, T2, []T3)
	fnWhen   func(T1, T2, []T3) bool
	fnReturn func()
}

// Handle sets a custom function to handle requests.
func (m *VarMocker30[T1, T2, T3]) Handle(fn func(T1, T2, []T3)) {
	m.fnHandle = fn
}

// When sets a condition function that determines if the mock should apply.
func (m *VarMocker30[T1, T2, T3]) When(fn func(T1, T2, []T3) bool) *VarMocker30[T1, T2, T3] {
	m.fnWhen = fn
	return m
}

// Return sets a function that returns predefined values.
func (m *VarMocker30[T1, T2, T3]) Return(fn func()) {
	if m.fnWhen == nil {
		m.fnWhen = func(T1, T2, []T3) bool { return true }
	}
	m.fnReturn = fn
}

// ReturnValue sets a return function with predefined values.
func (m *VarMocker30[T1, T2, T3]) ReturnValue() {
	m.Return(func() {})
}

// ReturnDefault sets a return function that returns zero values for all return types.
func (m *VarMocker30[T1, T2, T3]) ReturnDefault() {
	m.Return(func() {})
}

// VarInvoker30 is an Invoker implementation for VarMocker30.
type VarInvoker30[T1, T2, T3 any] struct {
	*VarMocker30[T1, T2, T3]
}

// Mode determines whether the mock operates in Handle mode or WhenReturn mode.
func (m *VarInvoker30[T1, T2, T3]) Mode() Mode {
	if m.fnHandle != nil {
		return ModeHandle
	}
	return ModeWhenReturn
}

// Handle executes the custom function if set.
func (m *VarInvoker30[T1, T2, T3]) Handle(params []any) []any {
	m.fnHandle(params[0].(T1), params[1].(T2), params[2].([]T3))
	return []any{}
}

// When checks if the condition function evaluates to true.
func (m *VarInvoker30[T1, T2, T3]) When(params []any) bool {
	if m.fnWhen == nil {
		return false
	}
	return m.fnWhen(params[0].(T1), params[1].(T2), params[2].([]T3))
}

// Return provides predefined response and error values.
func (m *VarInvoker30[T1, T2, T3]) Return() []any {
	m.fnReturn()
	return []any{}
}

// VarMock30 creates a new VarMocker30 instance.
func VarMock30[T1, T2, T3 any](f func(T1, T2, ...T3), r *Manager) *VarMocker30[T1, T2, T3] {
	PatchOnce(f)
	m := &VarMocker30[T1, T2, T3]{}
	i := &VarInvoker30[T1, T2, T3]{VarMocker30: m}
	r.addMocker(f, i)
	return m
}

/******************************** Mocker31 ***********************************/

type Mocker31[T1, T2, T3 any, R1 any] struct {
	fnHandle func(T1, T2, T3) R1
	fnWhen   func(T1, T2, T3) bool
	fnReturn func() R1
}

// Handle sets a custom function to handle requests.
func (m *Mocker31[T1, T2, T3, R1]) Handle(fn func(T1, T2, T3) R1) {
	m.fnHandle = fn
}

// When sets a condition function that determines if the mock should apply.
func (m *Mocker31[T1, T2, T3, R1]) When(fn func(T1, T2, T3) bool) *Mocker31[T1, T2, T3, R1] {
	m.fnWhen = fn
	return m
}

// Return sets a function that returns predefined values.
func (m *Mocker31[T1, T2, T3, R1]) Return(fn func() R1) {
	if m.fnWhen == nil {
		m.fnWhen = func(T1, T2, T3) bool { return true }
	}
	m.fnReturn = fn
}

// ReturnValue sets a return function with predefined values.
func (m *Mocker31[T1, T2, T3, R1]) ReturnValue(r1 R1) {
	m.Return(func() R1 { return r1 })
}

// ReturnDefault sets a return function that returns zero values for all return types.
func (m *Mocker31[T1, T2, T3, R1]) ReturnDefault() {
	m.Return(func() (r1 R1) { return r1 })
}

// Invoker31 is an Invoker implementation for Mocker31.
type Invoker31[T1, T2, T3 any, R1 any] struct {
	*Mocker31[T1, T2, T3, R1]
}

// Mode determines whether the mock operates in Handle mode or WhenReturn mode.
func (m *Invoker31[T1, T2, T3, R1]) Mode() Mode {
	if m.fnHandle != nil {
		return ModeHandle
	}
	return ModeWhenReturn
}

// Handle executes the custom function if set.
func (m *Invoker31[T1, T2, T3, R1]) Handle(params []any) []any {
	r1 := m.fnHandle(params[0].(T1), params[1].(T2), params[2].(T3))
	return []any{r1}
}

// When checks if the condition function evaluates to true.
func (m *Invoker31[T1, T2, T3, R1]) When(params []any) bool {
	if m.fnWhen == nil {
		return false
	}
	return m.fnWhen(params[0].(T1), params[1].(T2), params[2].(T3))
}

// Return provides predefined response and error values.
func (m *Invoker31[T1, T2, T3, R1]) Return() []any {
	r1 := m.fnReturn()
	return []any{r1}
}

// Mock31 creates a new Mocker31 instance.
func Mock31[T1, T2, T3 any, R1 any](f func(T1, T2, T3) R1, r *Manager) *Mocker31[T1, T2, T3, R1] {
	PatchOnce(f)
	m := &Mocker31[T1, T2, T3, R1]{}
	i := &Invoker31[T1, T2, T3, R1]{Mocker31: m}
	r.addMocker(f, i)
	return m
}

/******************************** VarMocker31 ***********************************/

type VarMocker31[T1, T2, T3 any, R1 any] struct {
	fnHandle func(T1, T2, []T3) R1
	fnWhen   func(T1, T2, []T3) bool
	fnReturn func() R1
}

// Handle sets a custom function to handle requests.
func (m *VarMocker31[T1, T2, T3, R1]) Handle(fn func(T1, T2, []T3) R1) {
	m.fnHandle = fn
}

// When sets a condition function that determines if the mock should apply.
func (m *VarMocker31[T1, T2, T3, R1]) When(fn func(T1, T2, []T3) bool) *VarMocker31[T1, T2, T3, R1] {
	m.fnWhen = fn
	return m
}

// Return sets a function that returns predefined values.
func (m *VarMocker31[T1, T2, T3, R1]) Return(fn func() R1) {
	if m.fnWhen == nil {
		m.fnWhen = func(T1, T2, []T3) bool { return true }
	}
	m.fnReturn = fn
}

// ReturnValue sets a return function with predefined values.
func (m *VarMocker31[T1, T2, T3, R1]) ReturnValue(r1 R1) {
	m.Return(func() R1 { return r1 })
}

// ReturnDefault sets a return function that returns zero values for all return types.
func (m *VarMocker31[T1, T2, T3, R1]) ReturnDefault() {
	m.Return(func() (r1 R1) { return r1 })
}

// VarInvoker31 is an Invoker implementation for VarMocker31.
type VarInvoker31[T1, T2, T3 any, R1 any] struct {
	*VarMocker31[T1, T2, T3, R1]
}

// Mode determines whether the mock operates in Handle mode or WhenReturn mode.
func (m *VarInvoker31[T1, T2, T3, R1]) Mode() Mode {
	if m.fnHandle != nil {
		return ModeHandle
	}
	return ModeWhenReturn
}

// Handle executes the custom function if set.
func (m *VarInvoker31[T1, T2, T3, R1]) Handle(params []any) []any {
	r1 := m.fnHandle(params[0].(T1), params[1].(T2), params[2].([]T3))
	return []any{r1}
}

// When checks if the condition function evaluates to true.
func (m *VarInvoker31[T1, T2, T3, R1]) When(params []any) bool {
	if m.fnWhen == nil {
		return false
	}
	return m.fnWhen(params[0].(T1), params[1].(T2), params[2].([]T3))
}

// Return provides predefined response and error values.
func (m *VarInvoker31[T1, T2, T3, R1]) Return() []any {
	r1 := m.fnReturn()
	return []any{r1}
}

// VarMock31 creates a new VarMocker31 instance.
func VarMock31[T1, T2, T3 any, R1 any](f func(T1, T2, ...T3) R1, r *Manager) *VarMocker31[T1, T2, T3, R1] {
	PatchOnce(f)
	m := &VarMocker31[T1, T2, T3, R1]{}
	i := &VarInvoker31[T1, T2, T3, R1]{VarMocker31: m}
	r.addMocker(f, i)
	return m
}

/******************************** Mocker32 ***********************************/

type Mocker32[T1, T2, T3 any, R1, R2 any] struct {
	fnHandle func(T1, T2, T3) (R1, R2)
	fnWhen   func(T1, T2, T3) bool
	fnReturn func() (R1, R2)
}

// Handle sets a custom function to handle requests.
func (m *Mocker32[T1, T2, T3, R1, R2]) Handle(fn func(T1, T2, T3) (R1, R2)) {
	m.fnHandle = fn
}

// When sets a condition function that determines if the mock should apply.
func (m *Mocker32[T1, T2, T3, R1, R2]) When(fn func(T1, T2, T3) bool) *Mocker32[T1, T2, T3, R1, R2] {
	m.fnWhen = fn
	return m
}

// Return sets a function that returns predefined values.
func (m *Mocker32[T1, T2, T3, R1, R2]) Return(fn func() (R1, R2)) {
	if m.fnWhen == nil {
		m.fnWhen = func(T1, T2, T3) bool { return true }
	}
	m.fnReturn = fn
}

// ReturnValue sets a return function with predefined values.
func (m *Mocker32[T1, T2, T3, R1, R2]) ReturnValue(r1 R1, r2 R2) {
	m.Return(func() (R1, R2) { return r1, r2 })
}

// ReturnDefault sets a return function that returns zero values for all return types.
func (m *Mocker32[T1, T2, T3, R1, R2]) ReturnDefault() {
	m.Return(func() (r1 R1, r2 R2) { return r1, r2 })
}

// Invoker32 is an Invoker implementation for Mocker32.
type Invoker32[T1, T2, T3 any, R1, R2 any] struct {
	*Mocker32[T1, T2, T3, R1, R2]
}

// Mode determines whether the mock operates in Handle mode or WhenReturn mode.
func (m *Invoker32[T1, T2, T3, R1, R2]) Mode() Mode {
	if m.fnHandle != nil {
		return ModeHandle
	}
	return ModeWhenReturn
}

// Handle executes the custom function if set.
func (m *Invoker32[T1, T2, T3, R1, R2]) Handle(params []any) []any {
	r1, r2 := m.fnHandle(params[0].(T1), params[1].(T2), params[2].(T3))
	return []any{r1, r2}
}

// When checks if the condition function evaluates to true.
func (m *Invoker32[T1, T2, T3, R1, R2]) When(params []any) bool {
	if m.fnWhen == nil {
		return false
	}
	return m.fnWhen(params[0].(T1), params[1].(T2), params[2].(T3))
}

// Return provides predefined response and error values.
func (m *Invoker32[T1, T2, T3, R1, R2]) Return() []any {
	r1, r2 := m.fnReturn()
	return []any{r1, r2}
}

// Mock32 creates a new Mocker32 instance.
func Mock32[T1, T2, T3 any, R1, R2 any](f func(T1, T2, T3) (R1, R2), r *Manager) *Mocker32[T1, T2, T3, R1, R2] {
	PatchOnce(f)
	m := &Mocker32[T1, T2, T3, R1, R2]{}
	i := &Invoker32[T1, T2, T3, R1, R2]{Mocker32: m}
	r.addMocker(f, i)
	return m
}

/******************************** VarMocker32 ***********************************/

type VarMocker32[T1, T2, T3 any, R1, R2 any] struct {
	fnHandle func(T1, T2, []T3) (R1, R2)
	fnWhen   func(T1, T2, []T3) bool
	fnReturn func() (R1, R2)
}

// Handle sets a custom function to handle requests.
func (m *VarMocker32[T1, T2, T3, R1, R2]) Handle(fn func(T1, T2, []T3) (R1, R2)) {
	m.fnHandle = fn
}

// When sets a condition function that determines if the mock should apply.
func (m *VarMocker32[T1, T2, T3, R1, R2]) When(fn func(T1, T2, []T3) bool) *VarMocker32[T1, T2, T3, R1, R2] {
	m.fnWhen = fn
	return m
}

// Return sets a function that returns predefined values.
func (m *VarMocker32[T1, T2, T3, R1, R2]) Return(fn func() (R1, R2)) {
	if m.fnWhen == nil {
		m.fnWhen = func(T1, T2, []T3) bool { return true }
	}
	m.fnReturn = fn
}

// ReturnValue sets a return function with predefined values.
func (m *VarMocker32[T1, T2, T3, R1, R2]) ReturnValue(r1 R1, r2 R2) {
	m.Return(func() (R1, R2) { return r1, r2 })
}

// ReturnDefault sets a return function that returns zero values for all return types.
func (m *VarMocker32[T1, T2, T3, R1, R2]) ReturnDefault() {
	m.Return(func() (r1 R1, r2 R2) { return r1, r2 })
}

// VarInvoker32 is an Invoker implementation for VarMocker32.
type VarInvoker32[T1, T2, T3 any, R1, R2 any] struct {
	*VarMocker32[T1, T2, T3, R1, R2]
}

// Mode determines whether the mock operates in Handle mode or WhenReturn mode.
func (m *VarInvoker32[T1, T2, T3, R1, R2]) Mode() Mode {
	if m.fnHandle != nil {
		return ModeHandle
	}
	return ModeWhenReturn
}

// Handle executes the custom function if set.
func (m *VarInvoker32[T1, T2, T3, R1, R2]) Handle(params []any) []any {
	r1, r2 := m.fnHandle(params[0].(T1), params[1].(T2), params[2].([]T3))
	return []any{r1, r2}
}

// When checks if the condition function evaluates to true.
func (m *VarInvoker32[T1, T2, T3, R1, R2]) When(params []any) bool {
	if m.fnWhen == nil {
		return false
	}
	return m.fnWhen(params[0].(T1), params[1].(T2), params[2].([]T3))
}

// Return provides predefined response and error values.
func (m *VarInvoker32[T1, T2, T3, R1, R2]) Return() []any {
	r1, r2 := m.fnReturn()
	return []any{r1, r2}
}

// VarMock32 creates a new VarMocker32 instance.
func VarMock32[T1, T2, T3 any, R1, R2 any](f func(T1, T2, ...T3) (R1, R2), r *Manager) *VarMocker32[T1, T2, T3, R1, R2] {
	PatchOnce(f)
	m := &VarMocker32[T1, T2, T3, R1, R2]{}
	i := &VarInvoker32[T1, T2, T3, R1, R2]{VarMocker32: m}
	r.addMocker(f, i)
	return m
}

/******************************** Mocker33 ***********************************/

type Mocker33[T1, T2, T3 any, R1, R2, R3 any] struct {
	fnHandle func(T1, T2, T3) (R1, R2, R3)
	fnWhen   func(T1, T2, T3) bool
	fnReturn func() (R1, R2, R3)
}

// Handle sets a custom function to handle requests.
func (m *Mocker33[T1, T2, T3, R1, R2, R3]) Handle(fn func(T1, T2, T3) (R1, R2, R3)) {
	m.fnHandle = fn
}

// When sets a condition function that determines if the mock should apply.
func (m *Mocker33[T1, T2, T3, R1, R2, R3]) When(fn func(T1, T2, T3) bool) *Mocker33[T1, T2, T3, R1, R2, R3] {
	m.fnWhen = fn
	return m
}

// Return sets a function that returns predefined values.
func (m *Mocker33[T1, T2, T3, R1, R2, R3]) Return(fn func() (R1, R2, R3)) {
	if m.fnWhen == nil {
		m.fnWhen = func(T1, T2, T3) bool { return true }
	}
	m.fnReturn = fn
}

// ReturnValue sets a return function with predefined values.
func (m *Mocker33[T1, T2, T3, R1, R2, R3]) ReturnValue(r1 R1, r2 R2, r3 R3) {
	m.Return(func() (R1, R2, R3) { return r1, r2, r3 })
}

// ReturnDefault sets a return function that returns zero values for all return types.
func (m *Mocker33[T1, T2, T3, R1, R2, R3]) ReturnDefault() {
	m.Return(func() (r1 R1, r2 R2, r3 R3) { return r1, r2, r3 })
}

// Invoker33 is an Invoker implementation for Mocker33.
type Invoker33[T1, T2, T3 any, R1, R2, R3 any] struct {
	*Mocker33[T1, T2, T3, R1, R2, R3]
}

// Mode determines whether the mock operates in Handle mode or WhenReturn mode.
func (m *Invoker33[T1, T2, T3, R1, R2, R3]) Mode() Mode {
	if m.fnHandle != nil {
		return ModeHandle
	}
	return ModeWhenReturn
}

// Handle executes the custom function if set.
func (m *Invoker33[T1, T2, T3, R1, R2, R3]) Handle(params []any) []any {
	r1, r2, r3 := m.fnHandle(params[0].(T1), params[1].(T2), params[2].(T3))
	return []any{r1, r2, r3}
}

// When checks if the condition function evaluates to true.
func (m *Invoker33[T1, T2, T3, R1, R2, R3]) When(params []any) bool {
	if m.fnWhen == nil {
		return false
	}
	return m.fnWhen(params[0].(T1), params[1].(T2), params[2].(T3))
}

// Return provides predefined response and error values.
func (m *Invoker33[T1, T2, T3, R1, R2, R3]) Return() []any {
	r1, r2, r3 := m.fnReturn()
	return []any{r1, r2, r3}
}

// Mock33 creates a new Mocker33 instance.
func Mock33[T1, T2, T3 any, R1, R2, R3 any](f func(T1, T2, T3) (R1, R2, R3), r *Manager) *Mocker33[T1, T2, T3, R1, R2, R3] {
	PatchOnce(f)
	m := &Mocker33[T1, T2, T3, R1, R2, R3]{}
	i := &Invoker33[T1, T2, T3, R1, R2, R3]{Mocker33: m}
	r.addMocker(f, i)
	return m
}

/******************************** VarMocker33 ***********************************/

type VarMocker33[T1, T2, T3 any, R1, R2, R3 any] struct {
	fnHandle func(T1, T2, []T3) (R1, R2, R3)
	fnWhen   func(T1, T2, []T3) bool
	fnReturn func() (R1, R2, R3)
}

// Handle sets a custom function to handle requests.
func (m *VarMocker33[T1, T2, T3, R1, R2, R3]) Handle(fn func(T1, T2, []T3) (R1, R2, R3)) {
	m.fnHandle = fn
}

// When sets a condition function that determines if the mock should apply.
func (m *VarMocker33[T1, T2, T3, R1, R2, R3]) When(fn func(T1, T2, []T3) bool) *VarMocker33[T1, T2, T3, R1, R2, R3] {
	m.fnWhen = fn
	return m
}

// Return sets a function that returns predefined values.
func (m *VarMocker33[T1, T2, T3, R1, R2, R3]) Return(fn func() (R1, R2, R3)) {
	if m.fnWhen == nil {
		m.fnWhen = func(T1, T2, []T3) bool { return true }
	}
	m.fnReturn = fn
}

// ReturnValue sets a return function with predefined values.
func (m *VarMocker33[T1, T2, T3, R1, R2, R3]) ReturnValue(r1 R1, r2 R2, r3 R3) {
	m.Return(func() (R1, R2, R3) { return r1, r2, r3 })
}

// ReturnDefault sets a return function that returns zero values for all return types.
func (m *VarMocker33[T1, T2, T3, R1, R2, R3]) ReturnDefault() {
	m.Return(func() (r1 R1, r2 R2, r3 R3) { return r1, r2, r3 })
}

// VarInvoker33 is an Invoker implementation for VarMocker33.
type VarInvoker33[T1, T2, T3 any, R1, R2, R3 any] struct {
	*VarMocker33[T1, T2, T3, R1, R2, R3]
}

// Mode determines whether the mock operates in Handle mode or WhenReturn mode.
func (m *VarInvoker33[T1, T2, T3, R1, R2, R3]) Mode() Mode {
	if m.fnHandle != nil {
		return ModeHandle
	}
	return ModeWhenReturn
}

// Handle executes the custom function if set.
func (m *VarInvoker33[T1, T2, T3, R1, R2, R3]) Handle(params []any) []any {
	r1, r2, r3 := m.fnHandle(params[0].(T1), params[1].(T2), params[2].([]T3))
	return []any{r1, r2, r3}
}

// When checks if the condition function evaluates to true.
func (m *VarInvoker33[T1, T2, T3, R1, R2, R3]) When(params []any) bool {
	if m.fnWhen == nil {
		return false
	}
	return m.fnWhen(params[0].(T1), params[1].(T2), params[2].([]T3))
}

// Return provides predefined response and error values.
func (m *VarInvoker33[T1, T2, T3, R1, R2, R3]) Return() []any {
	r1, r2, r3 := m.fnReturn()
	return []any{r1, r2, r3}
}

// VarMock33 creates a new VarMocker33 instance.
func VarMock33[T1, T2, T3 any, R1, R2, R3 any](f func(T1, T2, ...T3) (R1, R2, R3), r *Manager) *VarMocker33[T1, T2, T3, R1, R2, R3] {
	PatchOnce(f)
	m := &VarMocker33[T1, T2, T3, R1, R2, R3]{}
	i := &VarInvoker33[T1, T2, T3, R1, R2, R3]{VarMocker33: m}
	r.addMocker(f, i)
	return m
}

/******************************** Mocker34 ***********************************/

type Mocker34[T1, T2, T3 any, R1, R2, R3, R4 any] struct {
	fnHandle func(T1, T2, T3) (R1, R2, R3, R4)
	fnWhen   func(T1, T2, T3) bool
	fnReturn func() (R1, R2, R3, R4)
}

// Handle sets a custom function to handle requests.
func (m *Mocker34[T1, T2, T3, R1, R2, R3, R4]) Handle(fn func(T1, T2, T3) (R1, R2, R3, R4)) {
	m.fnHandle = fn
}

// When sets a condition function that determines if the mock should apply.
func (m *Mocker34[T1, T2, T3, R1, R2, R3, R4]) When(fn func(T1, T2, T3) bool) *Mocker34[T1, T2, T3, R1, R2, R3, R4] {
	m.fnWhen = fn
	return m
}

// Return sets a function that returns predefined values.
func (m *Mocker34[T1, T2, T3, R1, R2, R3, R4]) Return(fn func() (R1, R2, R3, R4)) {
	if m.fnWhen == nil {
		m.fnWhen = func(T1, T2, T3) bool { return true }
	}
	m.fnReturn = fn
}

// ReturnValue sets a return function with predefined values.
func (m *Mocker34[T1, T2, T3, R1, R2, R3, R4]) ReturnValue(r1 R1, r2 R2, r3 R3, r4 R4) {
	m.Return(func() (R1, R2, R3, R4) { return r1, r2, r3, r4 })
}

// ReturnDefault sets a return function that returns zero values for all return types.
func (m *Mocker34[T1, T2, T3, R1, R2, R3, R4]) ReturnDefault() {
	m.Return(func() (r1 R1, r2 R2, r3 R3, r4 R4) { return r1, r2, r3, r4 })
}

// Invoker34 is an Invoker implementation for Mocker34.
type Invoker34[T1, T2, T3 any, R1, R2, R3, R4 any] struct {
	*Mocker34[T1, T2, T3, R1, R2, R3, R4]
}

// Mode determines whether the mock operates in Handle mode or WhenReturn mode.
func (m *Invoker34[T1, T2, T3, R1, R2, R3, R4]) Mode() Mode {
	if m.fnHandle != nil {
		return ModeHandle
	}
	return ModeWhenReturn
}

// Handle executes the custom function if set.
func (m *Invoker34[T1, T2, T3, R1, R2, R3, R4]) Handle(params []any) []any {
	r1, r2, r3, r4 := m.fnHandle(params[0].(T1), params[1].(T2), params[2].(T3))
	return []any{r1, r2, r3, r4}
}

// When checks if the condition function evaluates to true.
func (m *Invoker34[T1, T2, T3, R1, R2, R3, R4]) When(params []any) bool {
	if m.fnWhen == nil {
		return false
	}
	return m.fnWhen(params[0].(T1), params[1].(T2), params[2].(T3))
}

// Return provides predefined response and error values.
func (m *Invoker34[T1, T2, T3, R1, R2, R3, R4]) Return() []any {
	r1, r2, r3, r4 := m.fnReturn()
	return []any{r1, r2, r3, r4}
}

// Mock34 creates a new Mocker34 instance.
func Mock34[T1, T2, T3 any, R1, R2, R3, R4 any](f func(T1, T2, T3) (R1, R2, R3, R4), r *Manager) *Mocker34[T1, T2, T3, R1, R2, R3, R4] {
	PatchOnce(f)
	m := &Mocker34[T1, T2, T3, R1, R2, R3, R4]{}
	i := &Invoker34[T1, T2, T3, R1, R2, R3, R4]{Mocker34: m}
	r.addMocker(f, i)
	return m
}

/******************************** VarMocker34 ***********************************/

type VarMocker34[T1, T2, T3 any, R1, R2, R3, R4 any] struct {
	fnHandle func(T1, T2, []T3) (R1, R2, R3, R4)
	fnWhen   func(T1, T2, []T3) bool
	fnReturn func() (R1, R2, R3, R4)
}

// Handle sets a custom function to handle requests.
func (m *VarMocker34[T1, T2, T3, R1, R2, R3, R4]) Handle(fn func(T1, T2, []T3) (R1, R2, R3, R4)) {
	m.fnHandle = fn
}

// When sets a condition function that determines if the mock should apply.
func (m *VarMocker34[T1, T2, T3, R1, R2, R3, R4]) When(fn func(T1, T2, []T3) bool) *VarMocker34[T1, T2, T3, R1, R2, R3, R4] {
	m.fnWhen = fn
	return m
}

// Return sets a function that returns predefined values.
func (m *VarMocker34[T1, T2, T3, R1, R2, R3, R4]) Return(fn func() (R1, R2, R3, R4)) {
	if m.fnWhen == nil {
		m.fnWhen = func(T1, T2, []T3) bool { return true }
	}
	m.fnReturn = fn
}

// ReturnValue sets a return function with predefined values.
func (m *VarMocker34[T1, T2, T3, R1, R2, R3, R4]) ReturnValue(r1 R1, r2 R2, r3 R3, r4 R4) {
	m.Return(func() (R1, R2, R3, R4) { return r1, r2, r3, r4 })
}

// ReturnDefault sets a return function that returns zero values for all return types.
func (m *VarMocker34[T1, T2, T3, R1, R2, R3, R4]) ReturnDefault() {
	m.Return(func() (r1 R1, r2 R2, r3 R3, r4 R4) { return r1, r2, r3, r4 })
}

// VarInvoker34 is an Invoker implementation for VarMocker34.
type VarInvoker34[T1, T2, T3 any, R1, R2, R3, R4 any] struct {
	*VarMocker34[T1, T2, T3, R1, R2, R3, R4]
}

// Mode determines whether the mock operates in Handle mode or WhenReturn mode.
func (m *VarInvoker34[T1, T2, T3, R1, R2, R3, R4]) Mode() Mode {
	if m.fnHandle != nil {
		return ModeHandle
	}
	return ModeWhenReturn
}

// Handle executes the custom function if set.
func (m *VarInvoker34[T1, T2, T3, R1, R2, R3, R4]) Handle(params []any) []any {
	r1, r2, r3, r4 := m.fnHandle(params[0].(T1), params[1].(T2), params[2].([]T3))
	return []any{r1, r2, r3, r4}
}

// When checks if the condition function evaluates to true.
func (m *VarInvoker34[T1, T2, T3, R1, R2, R3, R4]) When(params []any) bool {
	if m.fnWhen == nil {
		return false
	}
	return m.fnWhen(params[0].(T1), params[1].(T2), params[2].([]T3))
}

// Return provides predefined response and error values.
func (m *VarInvoker34[T1, T2, T3, R1, R2, R3, R4]) Return() []any {
	r1, r2, r3, r4 := m.fnReturn()
	return []any{r1, r2, r3, r4}
}

// VarMock34 creates a new VarMocker34 instance.
func VarMock34[T1, T2, T3 any, R1, R2, R3, R4 any](f func(T1, T2, ...T3) (R1, R2, R3, R4), r *Manager) *VarMocker34[T1, T2, T3, R1, R2, R3, R4] {
	PatchOnce(f)
	m := &VarMocker34[T1, T2, T3, R1, R2, R3, R4]{}
	i := &VarInvoker34[T1, T2, T3, R1, R2, R3, R4]{VarMocker34: m}
	r.addMocker(f, i)
	return m
}

/******************************** Mocker40 ***********************************/

type Mocker40[T1, T2, T3, T4 any] struct {
	fnHandle func(T1, T2, T3, T4)
	fnWhen   func(T1, T2, T3, T4) bool
	fnReturn func()
}

// Handle sets a custom function to handle requests.
func (m *Mocker40[T1, T2, T3, T4]) Handle(fn func(T1, T2, T3, T4)) {
	m.fnHandle = fn
}

// When sets a condition function that determines if the mock should apply.
func (m *Mocker40[T1, T2, T3, T4]) When(fn func(T1, T2, T3, T4) bool) *Mocker40[T1, T2, T3, T4] {
	m.fnWhen = fn
	return m
}

// Return sets a function that returns predefined values.
func (m *Mocker40[T1, T2, T3, T4]) Return(fn func()) {
	if m.fnWhen == nil {
		m.fnWhen = func(T1, T2, T3, T4) bool { return true }
	}
	m.fnReturn = fn
}

// ReturnValue sets a return function with predefined values.
func (m *Mocker40[T1, T2, T3, T4]) ReturnValue() {
	m.Return(func() {})
}

// ReturnDefault sets a return function that returns zero values for all return types.
func (m *Mocker40[T1, T2, T3, T4]) ReturnDefault() {
	m.Return(func() {})
}

// Invoker40 is an Invoker implementation for Mocker40.
type Invoker40[T1, T2, T3, T4 any] struct {
	*Mocker40[T1, T2, T3, T4]
}

// Mode determines whether the mock operates in Handle mode or WhenReturn mode.
func (m *Invoker40[T1, T2, T3, T4]) Mode() Mode {
	if m.fnHandle != nil {
		return ModeHandle
	}
	return ModeWhenReturn
}

// Handle executes the custom function if set.
func (m *Invoker40[T1, T2, T3, T4]) Handle(params []any) []any {
	m.fnHandle(params[0].(T1), params[1].(T2), params[2].(T3), params[3].(T4))
	return []any{}
}

// When checks if the condition function evaluates to true.
func (m *Invoker40[T1, T2, T3, T4]) When(params []any) bool {
	if m.fnWhen == nil {
		return false
	}
	return m.fnWhen(params[0].(T1), params[1].(T2), params[2].(T3), params[3].(T4))
}

// Return provides predefined response and error values.
func (m *Invoker40[T1, T2, T3, T4]) Return() []any {
	m.fnReturn()
	return []any{}
}

// Mock40 creates a new Mocker40 instance.
func Mock40[T1, T2, T3, T4 any](f func(T1, T2, T3, T4), r *Manager) *Mocker40[T1, T2, T3, T4] {
	PatchOnce(f)
	m := &Mocker40[T1, T2, T3, T4]{}
	i := &Invoker40[T1, T2, T3, T4]{Mocker40: m}
	r.addMocker(f, i)
	return m
}

/******************************** VarMocker40 ***********************************/

type VarMocker40[T1, T2, T3, T4 any] struct {
	fnHandle func(T1, T2, T3, []T4)
	fnWhen   func(T1, T2, T3, []T4) bool
	fnReturn func()
}

// Handle sets a custom function to handle requests.
func (m *VarMocker40[T1, T2, T3, T4]) Handle(fn func(T1, T2, T3, []T4)) {
	m.fnHandle = fn
}

// When sets a condition function that determines if the mock should apply.
func (m *VarMocker40[T1, T2, T3, T4]) When(fn func(T1, T2, T3, []T4) bool) *VarMocker40[T1, T2, T3, T4] {
	m.fnWhen = fn
	return m
}

// Return sets a function that returns predefined values.
func (m *VarMocker40[T1, T2, T3, T4]) Return(fn func()) {
	if m.fnWhen == nil {
		m.fnWhen = func(T1, T2, T3, []T4) bool { return true }
	}
	m.fnReturn = fn
}

// ReturnValue sets a return function with predefined values.
func (m *VarMocker40[T1, T2, T3, T4]) ReturnValue() {
	m.Return(func() {})
}

// ReturnDefault sets a return function that returns zero values for all return types.
func (m *VarMocker40[T1, T2, T3, T4]) ReturnDefault() {
	m.Return(func() {})
}

// VarInvoker40 is an Invoker implementation for VarMocker40.
type VarInvoker40[T1, T2, T3, T4 any] struct {
	*VarMocker40[T1, T2, T3, T4]
}

// Mode determines whether the mock operates in Handle mode or WhenReturn mode.
func (m *VarInvoker40[T1, T2, T3, T4]) Mode() Mode {
	if m.fnHandle != nil {
		return ModeHandle
	}
	return ModeWhenReturn
}

// Handle executes the custom function if set.
func (m *VarInvoker40[T1, T2, T3, T4]) Handle(params []any) []any {
	m.fnHandle(params[0].(T1), params[1].(T2), params[2].(T3), params[3].([]T4))
	return []any{}
}

// When checks if the condition function evaluates to true.
func (m *VarInvoker40[T1, T2, T3, T4]) When(params []any) bool {
	if m.fnWhen == nil {
		return false
	}
	return m.fnWhen(params[0].(T1), params[1].(T2), params[2].(T3), params[3].([]T4))
}

// Return provides predefined response and error values.
func (m *VarInvoker40[T1, T2, T3, T4]) Return() []any {
	m.fnReturn()
	return []any{}
}

// VarMock40 creates a new VarMocker40 instance.
func VarMock40[T1, T2, T3, T4 any](f func(T1, T2, T3, ...T4), r *Manager) *VarMocker40[T1, T2, T3, T4] {
	PatchOnce(f)
	m := &VarMocker40[T1, T2, T3, T4]{}
	i := &VarInvoker40[T1, T2, T3, T4]{VarMocker40: m}
	r.addMocker(f, i)
	return m
}

/******************************** Mocker41 ***********************************/

type Mocker41[T1, T2, T3, T4 any, R1 any] struct {
	fnHandle func(T1, T2, T3, T4) R1
	fnWhen   func(T1, T2, T3, T4) bool
	fnReturn func() R1
}

// Handle sets a custom function to handle requests.
func (m *Mocker41[T1, T2, T3, T4, R1]) Handle(fn func(T1, T2, T3, T4) R1) {
	m.fnHandle = fn
}

// When sets a condition function that determines if the mock should apply.
func (m *Mocker41[T1, T2, T3, T4, R1]) When(fn func(T1, T2, T3, T4) bool) *Mocker41[T1, T2, T3, T4, R1] {
	m.fnWhen = fn
	return m
}

// Return sets a function that returns predefined values.
func (m *Mocker41[T1, T2, T3, T4, R1]) Return(fn func() R1) {
	if m.fnWhen == nil {
		m.fnWhen = func(T1, T2, T3, T4) bool { return true }
	}
	m.fnReturn = fn
}

// ReturnValue sets a return function with predefined values.
func (m *Mocker41[T1, T2, T3, T4, R1]) ReturnValue(r1 R1) {
	m.Return(func() R1 { return r1 })
}

// ReturnDefault sets a return function that returns zero values for all return types.
func (m *Mocker41[T1, T2, T3, T4, R1]) ReturnDefault() {
	m.Return(func() (r1 R1) { return r1 })
}

// Invoker41 is an Invoker implementation for Mocker41.
type Invoker41[T1, T2, T3, T4 any, R1 any] struct {
	*Mocker41[T1, T2, T3, T4, R1]
}

// Mode determines whether the mock operates in Handle mode or WhenReturn mode.
func (m *Invoker41[T1, T2, T3, T4, R1]) Mode() Mode {
	if m.fnHandle != nil {
		return ModeHandle
	}
	return ModeWhenReturn
}

// Handle executes the custom function if set.
func (m *Invoker41[T1, T2, T3, T4, R1]) Handle(params []any) []any {
	r1 := m.fnHandle(params[0].(T1), params[1].(T2), params[2].(T3), params[3].(T4))
	return []any{r1}
}

// When checks if the condition function evaluates to true.
func (m *Invoker41[T1, T2, T3, T4, R1]) When(params []any) bool {
	if m.fnWhen == nil {
		return false
	}
	return m.fnWhen(params[0].(T1), params[1].(T2), params[2].(T3), params[3].(T4))
}

// Return provides predefined response and error values.
func (m *Invoker41[T1, T2, T3, T4, R1]) Return() []any {
	r1 := m.fnReturn()
	return []any{r1}
}

// Mock41 creates a new Mocker41 instance.
func Mock41[T1, T2, T3, T4 any, R1 any](f func(T1, T2, T3, T4) R1, r *Manager) *Mocker41[T1, T2, T3, T4, R1] {
	PatchOnce(f)
	m := &Mocker41[T1, T2, T3, T4, R1]{}
	i := &Invoker41[T1, T2, T3, T4, R1]{Mocker41: m}
	r.addMocker(f, i)
	return m
}

/******************************** VarMocker41 ***********************************/

type VarMocker41[T1, T2, T3, T4 any, R1 any] struct {
	fnHandle func(T1, T2, T3, []T4) R1
	fnWhen   func(T1, T2, T3, []T4) bool
	fnReturn func() R1
}

// Handle sets a custom function to handle requests.
func (m *VarMocker41[T1, T2, T3, T4, R1]) Handle(fn func(T1, T2, T3, []T4) R1) {
	m.fnHandle = fn
}

// When sets a condition function that determines if the mock should apply.
func (m *VarMocker41[T1, T2, T3, T4, R1]) When(fn func(T1, T2, T3, []T4) bool) *VarMocker41[T1, T2, T3, T4, R1] {
	m.fnWhen = fn
	return m
}

// Return sets a function that returns predefined values.
func (m *VarMocker41[T1, T2, T3, T4, R1]) Return(fn func() R1) {
	if m.fnWhen == nil {
		m.fnWhen = func(T1, T2, T3, []T4) bool { return true }
	}
	m.fnReturn = fn
}

// ReturnValue sets a return function with predefined values.
func (m *VarMocker41[T1, T2, T3, T4, R1]) ReturnValue(r1 R1) {
	m.Return(func() R1 { return r1 })
}

// ReturnDefault sets a return function that returns zero values for all return types.
func (m *VarMocker41[T1, T2, T3, T4, R1]) ReturnDefault() {
	m.Return(func() (r1 R1) { return r1 })
}

// VarInvoker41 is an Invoker implementation for VarMocker41.
type VarInvoker41[T1, T2, T3, T4 any, R1 any] struct {
	*VarMocker41[T1, T2, T3, T4, R1]
}

// Mode determines whether the mock operates in Handle mode or WhenReturn mode.
func (m *VarInvoker41[T1, T2, T3, T4, R1]) Mode() Mode {
	if m.fnHandle != nil {
		return ModeHandle
	}
	return ModeWhenReturn
}

// Handle executes the custom function if set.
func (m *VarInvoker41[T1, T2, T3, T4, R1]) Handle(params []any) []any {
	r1 := m.fnHandle(params[0].(T1), params[1].(T2), params[2].(T3), params[3].([]T4))
	return []any{r1}
}

// When checks if the condition function evaluates to true.
func (m *VarInvoker41[T1, T2, T3, T4, R1]) When(params []any) bool {
	if m.fnWhen == nil {
		return false
	}
	return m.fnWhen(params[0].(T1), params[1].(T2), params[2].(T3), params[3].([]T4))
}

// Return provides predefined response and error values.
func (m *VarInvoker41[T1, T2, T3, T4, R1]) Return() []any {
	r1 := m.fnReturn()
	return []any{r1}
}

// VarMock41 creates a new VarMocker41 instance.
func VarMock41[T1, T2, T3, T4 any, R1 any](f func(T1, T2, T3, ...T4) R1, r *Manager) *VarMocker41[T1, T2, T3, T4, R1] {
	PatchOnce(f)
	m := &VarMocker41[T1, T2, T3, T4, R1]{}
	i := &VarInvoker41[T1, T2, T3, T4, R1]{VarMocker41: m}
	r.addMocker(f, i)
	return m
}

/******************************** Mocker42 ***********************************/

type Mocker42[T1, T2, T3, T4 any, R1, R2 any] struct {
	fnHandle func(T1, T2, T3, T4) (R1, R2)
	fnWhen   func(T1, T2, T3, T4) bool
	fnReturn func() (R1, R2)
}

// Handle sets a custom function to handle requests.
func (m *Mocker42[T1, T2, T3, T4, R1, R2]) Handle(fn func(T1, T2, T3, T4) (R1, R2)) {
	m.fnHandle = fn
}

// When sets a condition function that determines if the mock should apply.
func (m *Mocker42[T1, T2, T3, T4, R1, R2]) When(fn func(T1, T2, T3, T4) bool) *Mocker42[T1, T2, T3, T4, R1, R2] {
	m.fnWhen = fn
	return m
}

// Return sets a function that returns predefined values.
func (m *Mocker42[T1, T2, T3, T4, R1, R2]) Return(fn func() (R1, R2)) {
	if m.fnWhen == nil {
		m.fnWhen = func(T1, T2, T3, T4) bool { return true }
	}
	m.fnReturn = fn
}

// ReturnValue sets a return function with predefined values.
func (m *Mocker42[T1, T2, T3, T4, R1, R2]) ReturnValue(r1 R1, r2 R2) {
	m.Return(func() (R1, R2) { return r1, r2 })
}

// ReturnDefault sets a return function that returns zero values for all return types.
func (m *Mocker42[T1, T2, T3, T4, R1, R2]) ReturnDefault() {
	m.Return(func() (r1 R1, r2 R2) { return r1, r2 })
}

// Invoker42 is an Invoker implementation for Mocker42.
type Invoker42[T1, T2, T3, T4 any, R1, R2 any] struct {
	*Mocker42[T1, T2, T3, T4, R1, R2]
}

// Mode determines whether the mock operates in Handle mode or WhenReturn mode.
func (m *Invoker42[T1, T2, T3, T4, R1, R2]) Mode() Mode {
	if m.fnHandle != nil {
		return ModeHandle
	}
	return ModeWhenReturn
}

// Handle executes the custom function if set.
func (m *Invoker42[T1, T2, T3, T4, R1, R2]) Handle(params []any) []any {
	r1, r2 := m.fnHandle(params[0].(T1), params[1].(T2), params[2].(T3), params[3].(T4))
	return []any{r1, r2}
}

// When checks if the condition function evaluates to true.
func (m *Invoker42[T1, T2, T3, T4, R1, R2]) When(params []any) bool {
	if m.fnWhen == nil {
		return false
	}
	return m.fnWhen(params[0].(T1), params[1].(T2), params[2].(T3), params[3].(T4))
}

// Return provides predefined response and error values.
func (m *Invoker42[T1, T2, T3, T4, R1, R2]) Return() []any {
	r1, r2 := m.fnReturn()
	return []any{r1, r2}
}

// Mock42 creates a new Mocker42 instance.
func Mock42[T1, T2, T3, T4 any, R1, R2 any](f func(T1, T2, T3, T4) (R1, R2), r *Manager) *Mocker42[T1, T2, T3, T4, R1, R2] {
	PatchOnce(f)
	m := &Mocker42[T1, T2, T3, T4, R1, R2]{}
	i := &Invoker42[T1, T2, T3, T4, R1, R2]{Mocker42: m}
	r.addMocker(f, i)
	return m
}

/******************************** VarMocker42 ***********************************/

type VarMocker42[T1, T2, T3, T4 any, R1, R2 any] struct {
	fnHandle func(T1, T2, T3, []T4) (R1, R2)
	fnWhen   func(T1, T2, T3, []T4) bool
	fnReturn func() (R1, R2)
}

// Handle sets a custom function to handle requests.
func (m *VarMocker42[T1, T2, T3, T4, R1, R2]) Handle(fn func(T1, T2, T3, []T4) (R1, R2)) {
	m.fnHandle = fn
}

// When sets a condition function that determines if the mock should apply.
func (m *VarMocker42[T1, T2, T3, T4, R1, R2]) When(fn func(T1, T2, T3, []T4) bool) *VarMocker42[T1, T2, T3, T4, R1, R2] {
	m.fnWhen = fn
	return m
}

// Return sets a function that returns predefined values.
func (m *VarMocker42[T1, T2, T3, T4, R1, R2]) Return(fn func() (R1, R2)) {
	if m.fnWhen == nil {
		m.fnWhen = func(T1, T2, T3, []T4) bool { return true }
	}
	m.fnReturn = fn
}

// ReturnValue sets a return function with predefined values.
func (m *VarMocker42[T1, T2, T3, T4, R1, R2]) ReturnValue(r1 R1, r2 R2) {
	m.Return(func() (R1, R2) { return r1, r2 })
}

// ReturnDefault sets a return function that returns zero values for all return types.
func (m *VarMocker42[T1, T2, T3, T4, R1, R2]) ReturnDefault() {
	m.Return(func() (r1 R1, r2 R2) { return r1, r2 })
}

// VarInvoker42 is an Invoker implementation for VarMocker42.
type VarInvoker42[T1, T2, T3, T4 any, R1, R2 any] struct {
	*VarMocker42[T1, T2, T3, T4, R1, R2]
}

// Mode determines whether the mock operates in Handle mode or WhenReturn mode.
func (m *VarInvoker42[T1, T2, T3, T4, R1, R2]) Mode() Mode {
	if m.fnHandle != nil {
		return ModeHandle
	}
	return ModeWhenReturn
}

// Handle executes the custom function if set.
func (m *VarInvoker42[T1, T2, T3, T4, R1, R2]) Handle(params []any) []any {
	r1, r2 := m.fnHandle(params[0].(T1), params[1].(T2), params[2].(T3), params[3].([]T4))
	return []any{r1, r2}
}

// When checks if the condition function evaluates to true.
func (m *VarInvoker42[T1, T2, T3, T4, R1, R2]) When(params []any) bool {
	if m.fnWhen == nil {
		return false
	}
	return m.fnWhen(params[0].(T1), params[1].(T2), params[2].(T3), params[3].([]T4))
}

// Return provides predefined response and error values.
func (m *VarInvoker42[T1, T2, T3, T4, R1, R2]) Return() []any {
	r1, r2 := m.fnReturn()
	return []any{r1, r2}
}

// VarMock42 creates a new VarMocker42 instance.
func VarMock42[T1, T2, T3, T4 any, R1, R2 any](f func(T1, T2, T3, ...T4) (R1, R2), r *Manager) *VarMocker42[T1, T2, T3, T4, R1, R2] {
	PatchOnce(f)
	m := &VarMocker42[T1, T2, T3, T4, R1, R2]{}
	i := &VarInvoker42[T1, T2, T3, T4, R1, R2]{VarMocker42: m}
	r.addMocker(f, i)
	return m
}

/******************************** Mocker43 ***********************************/

type Mocker43[T1, T2, T3, T4 any, R1, R2, R3 any] struct {
	fnHandle func(T1, T2, T3, T4) (R1, R2, R3)
	fnWhen   func(T1, T2, T3, T4) bool
	fnReturn func() (R1, R2, R3)
}

// Handle sets a custom function to handle requests.
func (m *Mocker43[T1, T2, T3, T4, R1, R2, R3]) Handle(fn func(T1, T2, T3, T4) (R1, R2, R3)) {
	m.fnHandle = fn
}

// When sets a condition function that determines if the mock should apply.
func (m *Mocker43[T1, T2, T3, T4, R1, R2, R3]) When(fn func(T1, T2, T3, T4) bool) *Mocker43[T1, T2, T3, T4, R1, R2, R3] {
	m.fnWhen = fn
	return m
}

// Return sets a function that returns predefined values.
func (m *Mocker43[T1, T2, T3, T4, R1, R2, R3]) Return(fn func() (R1, R2, R3)) {
	if m.fnWhen == nil {
		m.fnWhen = func(T1, T2, T3, T4) bool { return true }
	}
	m.fnReturn = fn
}

// ReturnValue sets a return function with predefined values.
func (m *Mocker43[T1, T2, T3, T4, R1, R2, R3]) ReturnValue(r1 R1, r2 R2, r3 R3) {
	m.Return(func() (R1, R2, R3) { return r1, r2, r3 })
}

// ReturnDefault sets a return function that returns zero values for all return types.
func (m *Mocker43[T1, T2, T3, T4, R1, R2, R3]) ReturnDefault() {
	m.Return(func() (r1 R1, r2 R2, r3 R3) { return r1, r2, r3 })
}

// Invoker43 is an Invoker implementation for Mocker43.
type Invoker43[T1, T2, T3, T4 any, R1, R2, R3 any] struct {
	*Mocker43[T1, T2, T3, T4, R1, R2, R3]
}

// Mode determines whether the mock operates in Handle mode or WhenReturn mode.
func (m *Invoker43[T1, T2, T3, T4, R1, R2, R3]) Mode() Mode {
	if m.fnHandle != nil {
		return ModeHandle
	}
	return ModeWhenReturn
}

// Handle executes the custom function if set.
func (m *Invoker43[T1, T2, T3, T4, R1, R2, R3]) Handle(params []any) []any {
	r1, r2, r3 := m.fnHandle(params[0].(T1), params[1].(T2), params[2].(T3), params[3].(T4))
	return []any{r1, r2, r3}
}

// When checks if the condition function evaluates to true.
func (m *Invoker43[T1, T2, T3, T4, R1, R2, R3]) When(params []any) bool {
	if m.fnWhen == nil {
		return false
	}
	return m.fnWhen(params[0].(T1), params[1].(T2), params[2].(T3), params[3].(T4))
}

// Return provides predefined response and error values.
func (m *Invoker43[T1, T2, T3, T4, R1, R2, R3]) Return() []any {
	r1, r2, r3 := m.fnReturn()
	return []any{r1, r2, r3}
}

// Mock43 creates a new Mocker43 instance.
func Mock43[T1, T2, T3, T4 any, R1, R2, R3 any](f func(T1, T2, T3, T4) (R1, R2, R3), r *Manager) *Mocker43[T1, T2, T3, T4, R1, R2, R3] {
	PatchOnce(f)
	m := &Mocker43[T1, T2, T3, T4, R1, R2, R3]{}
	i := &Invoker43[T1, T2, T3, T4, R1, R2, R3]{Mocker43: m}
	r.addMocker(f, i)
	return m
}

/******************************** VarMocker43 ***********************************/

type VarMocker43[T1, T2, T3, T4 any, R1, R2, R3 any] struct {
	fnHandle func(T1, T2, T3, []T4) (R1, R2, R3)
	fnWhen   func(T1, T2, T3, []T4) bool
	fnReturn func() (R1, R2, R3)
}

// Handle sets a custom function to handle requests.
func (m *VarMocker43[T1, T2, T3, T4, R1, R2, R3]) Handle(fn func(T1, T2, T3, []T4) (R1, R2, R3)) {
	m.fnHandle = fn
}

// When sets a condition function that determines if the mock should apply.
func (m *VarMocker43[T1, T2, T3, T4, R1, R2, R3]) When(fn func(T1, T2, T3, []T4) bool) *VarMocker43[T1, T2, T3, T4, R1, R2, R3] {
	m.fnWhen = fn
	return m
}

// Return sets a function that returns predefined values.
func (m *VarMocker43[T1, T2, T3, T4, R1, R2, R3]) Return(fn func() (R1, R2, R3)) {
	if m.fnWhen == nil {
		m.fnWhen = func(T1, T2, T3, []T4) bool { return true }
	}
	m.fnReturn = fn
}

// ReturnValue sets a return function with predefined values.
func (m *VarMocker43[T1, T2, T3, T4, R1, R2, R3]) ReturnValue(r1 R1, r2 R2, r3 R3) {
	m.Return(func() (R1, R2, R3) { return r1, r2, r3 })
}

// ReturnDefault sets a return function that returns zero values for all return types.
func (m *VarMocker43[T1, T2, T3, T4, R1, R2, R3]) ReturnDefault() {
	m.Return(func() (r1 R1, r2 R2, r3 R3) { return r1, r2, r3 })
}

// VarInvoker43 is an Invoker implementation for VarMocker43.
type VarInvoker43[T1, T2, T3, T4 any, R1, R2, R3 any] struct {
	*VarMocker43[T1, T2, T3, T4, R1, R2, R3]
}

// Mode determines whether the mock operates in Handle mode or WhenReturn mode.
func (m *VarInvoker43[T1, T2, T3, T4, R1, R2, R3]) Mode() Mode {
	if m.fnHandle != nil {
		return ModeHandle
	}
	return ModeWhenReturn
}

// Handle executes the custom function if set.
func (m *VarInvoker43[T1, T2, T3, T4, R1, R2, R3]) Handle(params []any) []any {
	r1, r2, r3 := m.fnHandle(params[0].(T1), params[1].(T2), params[2].(T3), params[3].([]T4))
	return []any{r1, r2, r3}
}

// When checks if the condition function evaluates to true.
func (m *VarInvoker43[T1, T2, T3, T4, R1, R2, R3]) When(params []any) bool {
	if m.fnWhen == nil {
		return false
	}
	return m.fnWhen(params[0].(T1), params[1].(T2), params[2].(T3), params[3].([]T4))
}

// Return provides predefined response and error values.
func (m *VarInvoker43[T1, T2, T3, T4, R1, R2, R3]) Return() []any {
	r1, r2, r3 := m.fnReturn()
	return []any{r1, r2, r3}
}

// VarMock43 creates a new VarMocker43 instance.
func VarMock43[T1, T2, T3, T4 any, R1, R2, R3 any](f func(T1, T2, T3, ...T4) (R1, R2, R3), r *Manager) *VarMocker43[T1, T2, T3, T4, R1, R2, R3] {
	PatchOnce(f)
	m := &VarMocker43[T1, T2, T3, T4, R1, R2, R3]{}
	i := &VarInvoker43[T1, T2, T3, T4, R1, R2, R3]{VarMocker43: m}
	r.addMocker(f, i)
	return m
}

/******************************** Mocker44 ***********************************/

type Mocker44[T1, T2, T3, T4 any, R1, R2, R3, R4 any] struct {
	fnHandle func(T1, T2, T3, T4) (R1, R2, R3, R4)
	fnWhen   func(T1, T2, T3, T4) bool
	fnReturn func() (R1, R2, R3, R4)
}

// Handle sets a custom function to handle requests.
func (m *Mocker44[T1, T2, T3, T4, R1, R2, R3, R4]) Handle(fn func(T1, T2, T3, T4) (R1, R2, R3, R4)) {
	m.fnHandle = fn
}

// When sets a condition function that determines if the mock should apply.
func (m *Mocker44[T1, T2, T3, T4, R1, R2, R3, R4]) When(fn func(T1, T2, T3, T4) bool) *Mocker44[T1, T2, T3, T4, R1, R2, R3, R4] {
	m.fnWhen = fn
	return m
}

// Return sets a function that returns predefined values.
func (m *Mocker44[T1, T2, T3, T4, R1, R2, R3, R4]) Return(fn func() (R1, R2, R3, R4)) {
	if m.fnWhen == nil {
		m.fnWhen = func(T1, T2, T3, T4) bool { return true }
	}
	m.fnReturn = fn
}

// ReturnValue sets a return function with predefined values.
func (m *Mocker44[T1, T2, T3, T4, R1, R2, R3, R4]) ReturnValue(r1 R1, r2 R2, r3 R3, r4 R4) {
	m.Return(func() (R1, R2, R3, R4) { return r1, r2, r3, r4 })
}

// ReturnDefault sets a return function that returns zero values for all return types.
func (m *Mocker44[T1, T2, T3, T4, R1, R2, R3, R4]) ReturnDefault() {
	m.Return(func() (r1 R1, r2 R2, r3 R3, r4 R4) { return r1, r2, r3, r4 })
}

// Invoker44 is an Invoker implementation for Mocker44.
type Invoker44[T1, T2, T3, T4 any, R1, R2, R3, R4 any] struct {
	*Mocker44[T1, T2, T3, T4, R1, R2, R3, R4]
}

// Mode determines whether the mock operates in Handle mode or WhenReturn mode.
func (m *Invoker44[T1, T2, T3, T4, R1, R2, R3, R4]) Mode() Mode {
	if m.fnHandle != nil {
		return ModeHandle
	}
	return ModeWhenReturn
}

// Handle executes the custom function if set.
func (m *Invoker44[T1, T2, T3, T4, R1, R2, R3, R4]) Handle(params []any) []any {
	r1, r2, r3, r4 := m.fnHandle(params[0].(T1), params[1].(T2), params[2].(T3), params[3].(T4))
	return []any{r1, r2, r3, r4}
}

// When checks if the condition function evaluates to true.
func (m *Invoker44[T1, T2, T3, T4, R1, R2, R3, R4]) When(params []any) bool {
	if m.fnWhen == nil {
		return false
	}
	return m.fnWhen(params[0].(T1), params[1].(T2), params[2].(T3), params[3].(T4))
}

// Return provides predefined response and error values.
func (m *Invoker44[T1, T2, T3, T4, R1, R2, R3, R4]) Return() []any {
	r1, r2, r3, r4 := m.fnReturn()
	return []any{r1, r2, r3, r4}
}

// Mock44 creates a new Mocker44 instance.
func Mock44[T1, T2, T3, T4 any, R1, R2, R3, R4 any](f func(T1, T2, T3, T4) (R1, R2, R3, R4), r *Manager) *Mocker44[T1, T2, T3, T4, R1, R2, R3, R4] {
	PatchOnce(f)
	m := &Mocker44[T1, T2, T3, T4, R1, R2, R3, R4]{}
	i := &Invoker44[T1, T2, T3, T4, R1, R2, R3, R4]{Mocker44: m}
	r.addMocker(f, i)
	return m
}

/******************************** VarMocker44 ***********************************/

type VarMocker44[T1, T2, T3, T4 any, R1, R2, R3, R4 any] struct {
	fnHandle func(T1, T2, T3, []T4) (R1, R2, R3, R4)
	fnWhen   func(T1, T2, T3, []T4) bool
	fnReturn func() (R1, R2, R3, R4)
}

// Handle sets a custom function to handle requests.
func (m *VarMocker44[T1, T2, T3, T4, R1, R2, R3, R4]) Handle(fn func(T1, T2, T3, []T4) (R1, R2, R3, R4)) {
	m.fnHandle = fn
}

// When sets a condition function that determines if the mock should apply.
func (m *VarMocker44[T1, T2, T3, T4, R1, R2, R3, R4]) When(fn func(T1, T2, T3, []T4) bool) *VarMocker44[T1, T2, T3, T4, R1, R2, R3, R4] {
	m.fnWhen = fn
	return m
}

// Return sets a function that returns predefined values.
func (m *VarMocker44[T1, T2, T3, T4, R1, R2, R3, R4]) Return(fn func() (R1, R2, R3, R4)) {
	if m.fnWhen == nil {
		m.fnWhen = func(T1, T2, T3, []T4) bool { return true }
	}
	m.fnReturn = fn
}

// ReturnValue sets a return function with predefined values.
func (m *VarMocker44[T1, T2, T3, T4, R1, R2, R3, R4]) ReturnValue(r1 R1, r2 R2, r3 R3, r4 R4) {
	m.Return(func() (R1, R2, R3, R4) { return r1, r2, r3, r4 })
}

// ReturnDefault sets a return function that returns zero values for all return types.
func (m *VarMocker44[T1, T2, T3, T4, R1, R2, R3, R4]) ReturnDefault() {
	m.Return(func() (r1 R1, r2 R2, r3 R3, r4 R4) { return r1, r2, r3, r4 })
}

// VarInvoker44 is an Invoker implementation for VarMocker44.
type VarInvoker44[T1, T2, T3, T4 any, R1, R2, R3, R4 any] struct {
	*VarMocker44[T1, T2, T3, T4, R1, R2, R3, R4]
}

// Mode determines whether the mock operates in Handle mode or WhenReturn mode.
func (m *VarInvoker44[T1, T2, T3, T4, R1, R2, R3, R4]) Mode() Mode {
	if m.fnHandle != nil {
		return ModeHandle
	}
	return ModeWhenReturn
}

// Handle executes the custom function if set.
func (m *VarInvoker44[T1, T2, T3, T4, R1, R2, R3, R4]) Handle(params []any) []any {
	r1, r2, r3, r4 := m.fnHandle(params[0].(T1), params[1].(T2), params[2].(T3), params[3].([]T4))
	return []any{r1, r2, r3, r4}
}

// When checks if the condition function evaluates to true.
func (m *VarInvoker44[T1, T2, T3, T4, R1, R2, R3, R4]) When(params []any) bool {
	if m.fnWhen == nil {
		return false
	}
	return m.fnWhen(params[0].(T1), params[1].(T2), params[2].(T3), params[3].([]T4))
}

// Return provides predefined response and error values.
func (m *VarInvoker44[T1, T2, T3, T4, R1, R2, R3, R4]) Return() []any {
	r1, r2, r3, r4 := m.fnReturn()
	return []any{r1, r2, r3, r4}
}

// VarMock44 creates a new VarMocker44 instance.
func VarMock44[T1, T2, T3, T4 any, R1, R2, R3, R4 any](f func(T1, T2, T3, ...T4) (R1, R2, R3, R4), r *Manager) *VarMocker44[T1, T2, T3, T4, R1, R2, R3, R4] {
	PatchOnce(f)
	m := &VarMocker44[T1, T2, T3, T4, R1, R2, R3, R4]{}
	i := &VarInvoker44[T1, T2, T3, T4, R1, R2, R3, R4]{VarMocker44: m}
	r.addMocker(f, i)
	return m
}

/******************************** Mocker50 ***********************************/

type Mocker50[T1, T2, T3, T4, T5 any] struct {
	fnHandle func(T1, T2, T3, T4, T5)
	fnWhen   func(T1, T2, T3, T4, T5) bool
	fnReturn func()
}

// Handle sets a custom function to handle requests.
func (m *Mocker50[T1, T2, T3, T4, T5]) Handle(fn func(T1, T2, T3, T4, T5)) {
	m.fnHandle = fn
}

// When sets a condition function that determines if the mock should apply.
func (m *Mocker50[T1, T2, T3, T4, T5]) When(fn func(T1, T2, T3, T4, T5) bool) *Mocker50[T1, T2, T3, T4, T5] {
	m.fnWhen = fn
	return m
}

// Return sets a function that returns predefined values.
func (m *Mocker50[T1, T2, T3, T4, T5]) Return(fn func()) {
	if m.fnWhen == nil {
		m.fnWhen = func(T1, T2, T3, T4, T5) bool { return true }
	}
	m.fnReturn = fn
}

// ReturnValue sets a return function with predefined values.
func (m *Mocker50[T1, T2, T3, T4, T5]) ReturnValue() {
	m.Return(func() {})
}

// ReturnDefault sets a return function that returns zero values for all return types.
func (m *Mocker50[T1, T2, T3, T4, T5]) ReturnDefault() {
	m.Return(func() {})
}

// Invoker50 is an Invoker implementation for Mocker50.
type Invoker50[T1, T2, T3, T4, T5 any] struct {
	*Mocker50[T1, T2, T3, T4, T5]
}

// Mode determines whether the mock operates in Handle mode or WhenReturn mode.
func (m *Invoker50[T1, T2, T3, T4, T5]) Mode() Mode {
	if m.fnHandle != nil {
		return ModeHandle
	}
	return ModeWhenReturn
}

// Handle executes the custom function if set.
func (m *Invoker50[T1, T2, T3, T4, T5]) Handle(params []any) []any {
	m.fnHandle(params[0].(T1), params[1].(T2), params[2].(T3), params[3].(T4), params[4].(T5))
	return []any{}
}

// When checks if the condition function evaluates to true.
func (m *Invoker50[T1, T2, T3, T4, T5]) When(params []any) bool {
	if m.fnWhen == nil {
		return false
	}
	return m.fnWhen(params[0].(T1), params[1].(T2), params[2].(T3), params[3].(T4), params[4].(T5))
}

// Return provides predefined response and error values.
func (m *Invoker50[T1, T2, T3, T4, T5]) Return() []any {
	m.fnReturn()
	return []any{}
}

// Mock50 creates a new Mocker50 instance.
func Mock50[T1, T2, T3, T4, T5 any](f func(T1, T2, T3, T4, T5), r *Manager) *Mocker50[T1, T2, T3, T4, T5] {
	PatchOnce(f)
	m := &Mocker50[T1, T2, T3, T4, T5]{}
	i := &Invoker50[T1, T2, T3, T4, T5]{Mocker50: m}
	r.addMocker(f, i)
	return m
}

/******************************** VarMocker50 ***********************************/

type VarMocker50[T1, T2, T3, T4, T5 any] struct {
	fnHandle func(T1, T2, T3, T4, []T5)
	fnWhen   func(T1, T2, T3, T4, []T5) bool
	fnReturn func()
}

// Handle sets a custom function to handle requests.
func (m *VarMocker50[T1, T2, T3, T4, T5]) Handle(fn func(T1, T2, T3, T4, []T5)) {
	m.fnHandle = fn
}

// When sets a condition function that determines if the mock should apply.
func (m *VarMocker50[T1, T2, T3, T4, T5]) When(fn func(T1, T2, T3, T4, []T5) bool) *VarMocker50[T1, T2, T3, T4, T5] {
	m.fnWhen = fn
	return m
}

// Return sets a function that returns predefined values.
func (m *VarMocker50[T1, T2, T3, T4, T5]) Return(fn func()) {
	if m.fnWhen == nil {
		m.fnWhen = func(T1, T2, T3, T4, []T5) bool { return true }
	}
	m.fnReturn = fn
}

// ReturnValue sets a return function with predefined values.
func (m *VarMocker50[T1, T2, T3, T4, T5]) ReturnValue() {
	m.Return(func() {})
}

// ReturnDefault sets a return function that returns zero values for all return types.
func (m *VarMocker50[T1, T2, T3, T4, T5]) ReturnDefault() {
	m.Return(func() {})
}

// VarInvoker50 is an Invoker implementation for VarMocker50.
type VarInvoker50[T1, T2, T3, T4, T5 any] struct {
	*VarMocker50[T1, T2, T3, T4, T5]
}

// Mode determines whether the mock operates in Handle mode or WhenReturn mode.
func (m *VarInvoker50[T1, T2, T3, T4, T5]) Mode() Mode {
	if m.fnHandle != nil {
		return ModeHandle
	}
	return ModeWhenReturn
}

// Handle executes the custom function if set.
func (m *VarInvoker50[T1, T2, T3, T4, T5]) Handle(params []any) []any {
	m.fnHandle(params[0].(T1), params[1].(T2), params[2].(T3), params[3].(T4), params[4].([]T5))
	return []any{}
}

// When checks if the condition function evaluates to true.
func (m *VarInvoker50[T1, T2, T3, T4, T5]) When(params []any) bool {
	if m.fnWhen == nil {
		return false
	}
	return m.fnWhen(params[0].(T1), params[1].(T2), params[2].(T3), params[3].(T4), params[4].([]T5))
}

// Return provides predefined response and error values.
func (m *VarInvoker50[T1, T2, T3, T4, T5]) Return() []any {
	m.fnReturn()
	return []any{}
}

// VarMock50 creates a new VarMocker50 instance.
func VarMock50[T1, T2, T3, T4, T5 any](f func(T1, T2, T3, T4, ...T5), r *Manager) *VarMocker50[T1, T2, T3, T4, T5] {
	PatchOnce(f)
	m := &VarMocker50[T1, T2, T3, T4, T5]{}
	i := &VarInvoker50[T1, T2, T3, T4, T5]{VarMocker50: m}
	r.addMocker(f, i)
	return m
}

/******************************** Mocker51 ***********************************/

type Mocker51[T1, T2, T3, T4, T5 any, R1 any] struct {
	fnHandle func(T1, T2, T3, T4, T5) R1
	fnWhen   func(T1, T2, T3, T4, T5) bool
	fnReturn func() R1
}

// Handle sets a custom function to handle requests.
func (m *Mocker51[T1, T2, T3, T4, T5, R1]) Handle(fn func(T1, T2, T3, T4, T5) R1) {
	m.fnHandle = fn
}

// When sets a condition function that determines if the mock should apply.
func (m *Mocker51[T1, T2, T3, T4, T5, R1]) When(fn func(T1, T2, T3, T4, T5) bool) *Mocker51[T1, T2, T3, T4, T5, R1] {
	m.fnWhen = fn
	return m
}

// Return sets a function that returns predefined values.
func (m *Mocker51[T1, T2, T3, T4, T5, R1]) Return(fn func() R1) {
	if m.fnWhen == nil {
		m.fnWhen = func(T1, T2, T3, T4, T5) bool { return true }
	}
	m.fnReturn = fn
}

// ReturnValue sets a return function with predefined values.
func (m *Mocker51[T1, T2, T3, T4, T5, R1]) ReturnValue(r1 R1) {
	m.Return(func() R1 { return r1 })
}

// ReturnDefault sets a return function that returns zero values for all return types.
func (m *Mocker51[T1, T2, T3, T4, T5, R1]) ReturnDefault() {
	m.Return(func() (r1 R1) { return r1 })
}

// Invoker51 is an Invoker implementation for Mocker51.
type Invoker51[T1, T2, T3, T4, T5 any, R1 any] struct {
	*Mocker51[T1, T2, T3, T4, T5, R1]
}

// Mode determines whether the mock operates in Handle mode or WhenReturn mode.
func (m *Invoker51[T1, T2, T3, T4, T5, R1]) Mode() Mode {
	if m.fnHandle != nil {
		return ModeHandle
	}
	return ModeWhenReturn
}

// Handle executes the custom function if set.
func (m *Invoker51[T1, T2, T3, T4, T5, R1]) Handle(params []any) []any {
	r1 := m.fnHandle(params[0].(T1), params[1].(T2), params[2].(T3), params[3].(T4), params[4].(T5))
	return []any{r1}
}

// When checks if the condition function evaluates to true.
func (m *Invoker51[T1, T2, T3, T4, T5, R1]) When(params []any) bool {
	if m.fnWhen == nil {
		return false
	}
	return m.fnWhen(params[0].(T1), params[1].(T2), params[2].(T3), params[3].(T4), params[4].(T5))
}

// Return provides predefined response and error values.
func (m *Invoker51[T1, T2, T3, T4, T5, R1]) Return() []any {
	r1 := m.fnReturn()
	return []any{r1}
}

// Mock51 creates a new Mocker51 instance.
func Mock51[T1, T2, T3, T4, T5 any, R1 any](f func(T1, T2, T3, T4, T5) R1, r *Manager) *Mocker51[T1, T2, T3, T4, T5, R1] {
	PatchOnce(f)
	m := &Mocker51[T1, T2, T3, T4, T5, R1]{}
	i := &Invoker51[T1, T2, T3, T4, T5, R1]{Mocker51: m}
	r.addMocker(f, i)
	return m
}

/******************************** VarMocker51 ***********************************/

type VarMocker51[T1, T2, T3, T4, T5 any, R1 any] struct {
	fnHandle func(T1, T2, T3, T4, []T5) R1
	fnWhen   func(T1, T2, T3, T4, []T5) bool
	fnReturn func() R1
}

// Handle sets a custom function to handle requests.
func (m *VarMocker51[T1, T2, T3, T4, T5, R1]) Handle(fn func(T1, T2, T3, T4, []T5) R1) {
	m.fnHandle = fn
}

// When sets a condition function that determines if the mock should apply.
func (m *VarMocker51[T1, T2, T3, T4, T5, R1]) When(fn func(T1, T2, T3, T4, []T5) bool) *VarMocker51[T1, T2, T3, T4, T5, R1] {
	m.fnWhen = fn
	return m
}

// Return sets a function that returns predefined values.
func (m *VarMocker51[T1, T2, T3, T4, T5, R1]) Return(fn func() R1) {
	if m.fnWhen == nil {
		m.fnWhen = func(T1, T2, T3, T4, []T5) bool { return true }
	}
	m.fnReturn = fn
}

// ReturnValue sets a return function with predefined values.
func (m *VarMocker51[T1, T2, T3, T4, T5, R1]) ReturnValue(r1 R1) {
	m.Return(func() R1 { return r1 })
}

// ReturnDefault sets a return function that returns zero values for all return types.
func (m *VarMocker51[T1, T2, T3, T4, T5, R1]) ReturnDefault() {
	m.Return(func() (r1 R1) { return r1 })
}

// VarInvoker51 is an Invoker implementation for VarMocker51.
type VarInvoker51[T1, T2, T3, T4, T5 any, R1 any] struct {
	*VarMocker51[T1, T2, T3, T4, T5, R1]
}

// Mode determines whether the mock operates in Handle mode or WhenReturn mode.
func (m *VarInvoker51[T1, T2, T3, T4, T5, R1]) Mode() Mode {
	if m.fnHandle != nil {
		return ModeHandle
	}
	return ModeWhenReturn
}

// Handle executes the custom function if set.
func (m *VarInvoker51[T1, T2, T3, T4, T5, R1]) Handle(params []any) []any {
	r1 := m.fnHandle(params[0].(T1), params[1].(T2), params[2].(T3), params[3].(T4), params[4].([]T5))
	return []any{r1}
}

// When checks if the condition function evaluates to true.
func (m *VarInvoker51[T1, T2, T3, T4, T5, R1]) When(params []any) bool {
	if m.fnWhen == nil {
		return false
	}
	return m.fnWhen(params[0].(T1), params[1].(T2), params[2].(T3), params[3].(T4), params[4].([]T5))
}

// Return provides predefined response and error values.
func (m *VarInvoker51[T1, T2, T3, T4, T5, R1]) Return() []any {
	r1 := m.fnReturn()
	return []any{r1}
}

// VarMock51 creates a new VarMocker51 instance.
func VarMock51[T1, T2, T3, T4, T5 any, R1 any](f func(T1, T2, T3, T4, ...T5) R1, r *Manager) *VarMocker51[T1, T2, T3, T4, T5, R1] {
	PatchOnce(f)
	m := &VarMocker51[T1, T2, T3, T4, T5, R1]{}
	i := &VarInvoker51[T1, T2, T3, T4, T5, R1]{VarMocker51: m}
	r.addMocker(f, i)
	return m
}

/******************************** Mocker52 ***********************************/

type Mocker52[T1, T2, T3, T4, T5 any, R1, R2 any] struct {
	fnHandle func(T1, T2, T3, T4, T5) (R1, R2)
	fnWhen   func(T1, T2, T3, T4, T5) bool
	fnReturn func() (R1, R2)
}

// Handle sets a custom function to handle requests.
func (m *Mocker52[T1, T2, T3, T4, T5, R1, R2]) Handle(fn func(T1, T2, T3, T4, T5) (R1, R2)) {
	m.fnHandle = fn
}

// When sets a condition function that determines if the mock should apply.
func (m *Mocker52[T1, T2, T3, T4, T5, R1, R2]) When(fn func(T1, T2, T3, T4, T5) bool) *Mocker52[T1, T2, T3, T4, T5, R1, R2] {
	m.fnWhen = fn
	return m
}

// Return sets a function that returns predefined values.
func (m *Mocker52[T1, T2, T3, T4, T5, R1, R2]) Return(fn func() (R1, R2)) {
	if m.fnWhen == nil {
		m.fnWhen = func(T1, T2, T3, T4, T5) bool { return true }
	}
	m.fnReturn = fn
}

// ReturnValue sets a return function with predefined values.
func (m *Mocker52[T1, T2, T3, T4, T5, R1, R2]) ReturnValue(r1 R1, r2 R2) {
	m.Return(func() (R1, R2) { return r1, r2 })
}

// ReturnDefault sets a return function that returns zero values for all return types.
func (m *Mocker52[T1, T2, T3, T4, T5, R1, R2]) ReturnDefault() {
	m.Return(func() (r1 R1, r2 R2) { return r1, r2 })
}

// Invoker52 is an Invoker implementation for Mocker52.
type Invoker52[T1, T2, T3, T4, T5 any, R1, R2 any] struct {
	*Mocker52[T1, T2, T3, T4, T5, R1, R2]
}

// Mode determines whether the mock operates in Handle mode or WhenReturn mode.
func (m *Invoker52[T1, T2, T3, T4, T5, R1, R2]) Mode() Mode {
	if m.fnHandle != nil {
		return ModeHandle
	}
	return ModeWhenReturn
}

// Handle executes the custom function if set.
func (m *Invoker52[T1, T2, T3, T4, T5, R1, R2]) Handle(params []any) []any {
	r1, r2 := m.fnHandle(params[0].(T1), params[1].(T2), params[2].(T3), params[3].(T4), params[4].(T5))
	return []any{r1, r2}
}

// When checks if the condition function evaluates to true.
func (m *Invoker52[T1, T2, T3, T4, T5, R1, R2]) When(params []any) bool {
	if m.fnWhen == nil {
		return false
	}
	return m.fnWhen(params[0].(T1), params[1].(T2), params[2].(T3), params[3].(T4), params[4].(T5))
}

// Return provides predefined response and error values.
func (m *Invoker52[T1, T2, T3, T4, T5, R1, R2]) Return() []any {
	r1, r2 := m.fnReturn()
	return []any{r1, r2}
}

// Mock52 creates a new Mocker52 instance.
func Mock52[T1, T2, T3, T4, T5 any, R1, R2 any](f func(T1, T2, T3, T4, T5) (R1, R2), r *Manager) *Mocker52[T1, T2, T3, T4, T5, R1, R2] {
	PatchOnce(f)
	m := &Mocker52[T1, T2, T3, T4, T5, R1, R2]{}
	i := &Invoker52[T1, T2, T3, T4, T5, R1, R2]{Mocker52: m}
	r.addMocker(f, i)
	return m
}

/******************************** VarMocker52 ***********************************/

type VarMocker52[T1, T2, T3, T4, T5 any, R1, R2 any] struct {
	fnHandle func(T1, T2, T3, T4, []T5) (R1, R2)
	fnWhen   func(T1, T2, T3, T4, []T5) bool
	fnReturn func() (R1, R2)
}

// Handle sets a custom function to handle requests.
func (m *VarMocker52[T1, T2, T3, T4, T5, R1, R2]) Handle(fn func(T1, T2, T3, T4, []T5) (R1, R2)) {
	m.fnHandle = fn
}

// When sets a condition function that determines if the mock should apply.
func (m *VarMocker52[T1, T2, T3, T4, T5, R1, R2]) When(fn func(T1, T2, T3, T4, []T5) bool) *VarMocker52[T1, T2, T3, T4, T5, R1, R2] {
	m.fnWhen = fn
	return m
}

// Return sets a function that returns predefined values.
func (m *VarMocker52[T1, T2, T3, T4, T5, R1, R2]) Return(fn func() (R1, R2)) {
	if m.fnWhen == nil {
		m.fnWhen = func(T1, T2, T3, T4, []T5) bool { return true }
	}
	m.fnReturn = fn
}

// ReturnValue sets a return function with predefined values.
func (m *VarMocker52[T1, T2, T3, T4, T5, R1, R2]) ReturnValue(r1 R1, r2 R2) {
	m.Return(func() (R1, R2) { return r1, r2 })
}

// ReturnDefault sets a return function that returns zero values for all return types.
func (m *VarMocker52[T1, T2, T3, T4, T5, R1, R2]) ReturnDefault() {
	m.Return(func() (r1 R1, r2 R2) { return r1, r2 })
}

// VarInvoker52 is an Invoker implementation for VarMocker52.
type VarInvoker52[T1, T2, T3, T4, T5 any, R1, R2 any] struct {
	*VarMocker52[T1, T2, T3, T4, T5, R1, R2]
}

// Mode determines whether the mock operates in Handle mode or WhenReturn mode.
func (m *VarInvoker52[T1, T2, T3, T4, T5, R1, R2]) Mode() Mode {
	if m.fnHandle != nil {
		return ModeHandle
	}
	return ModeWhenReturn
}

// Handle executes the custom function if set.
func (m *VarInvoker52[T1, T2, T3, T4, T5, R1, R2]) Handle(params []any) []any {
	r1, r2 := m.fnHandle(params[0].(T1), params[1].(T2), params[2].(T3), params[3].(T4), params[4].([]T5))
	return []any{r1, r2}
}

// When checks if the condition function evaluates to true.
func (m *VarInvoker52[T1, T2, T3, T4, T5, R1, R2]) When(params []any) bool {
	if m.fnWhen == nil {
		return false
	}
	return m.fnWhen(params[0].(T1), params[1].(T2), params[2].(T3), params[3].(T4), params[4].([]T5))
}

// Return provides predefined response and error values.
func (m *VarInvoker52[T1, T2, T3, T4, T5, R1, R2]) Return() []any {
	r1, r2 := m.fnReturn()
	return []any{r1, r2}
}

// VarMock52 creates a new VarMocker52 instance.
func VarMock52[T1, T2, T3, T4, T5 any, R1, R2 any](f func(T1, T2, T3, T4, ...T5) (R1, R2), r *Manager) *VarMocker52[T1, T2, T3, T4, T5, R1, R2] {
	PatchOnce(f)
	m := &VarMocker52[T1, T2, T3, T4, T5, R1, R2]{}
	i := &VarInvoker52[T1, T2, T3, T4, T5, R1, R2]{VarMocker52: m}
	r.addMocker(f, i)
	return m
}

/******************************** Mocker53 ***********************************/

type Mocker53[T1, T2, T3, T4, T5 any, R1, R2, R3 any] struct {
	fnHandle func(T1, T2, T3, T4, T5) (R1, R2, R3)
	fnWhen   func(T1, T2, T3, T4, T5) bool
	fnReturn func() (R1, R2, R3)
}

// Handle sets a custom function to handle requests.
func (m *Mocker53[T1, T2, T3, T4, T5, R1, R2, R3]) Handle(fn func(T1, T2, T3, T4, T5) (R1, R2, R3)) {
	m.fnHandle = fn
}

// When sets a condition function that determines if the mock should apply.
func (m *Mocker53[T1, T2, T3, T4, T5, R1, R2, R3]) When(fn func(T1, T2, T3, T4, T5) bool) *Mocker53[T1, T2, T3, T4, T5, R1, R2, R3] {
	m.fnWhen = fn
	return m
}

// Return sets a function that returns predefined values.
func (m *Mocker53[T1, T2, T3, T4, T5, R1, R2, R3]) Return(fn func() (R1, R2, R3)) {
	if m.fnWhen == nil {
		m.fnWhen = func(T1, T2, T3, T4, T5) bool { return true }
	}
	m.fnReturn = fn
}

// ReturnValue sets a return function with predefined values.
func (m *Mocker53[T1, T2, T3, T4, T5, R1, R2, R3]) ReturnValue(r1 R1, r2 R2, r3 R3) {
	m.Return(func() (R1, R2, R3) { return r1, r2, r3 })
}

// ReturnDefault sets a return function that returns zero values for all return types.
func (m *Mocker53[T1, T2, T3, T4, T5, R1, R2, R3]) ReturnDefault() {
	m.Return(func() (r1 R1, r2 R2, r3 R3) { return r1, r2, r3 })
}

// Invoker53 is an Invoker implementation for Mocker53.
type Invoker53[T1, T2, T3, T4, T5 any, R1, R2, R3 any] struct {
	*Mocker53[T1, T2, T3, T4, T5, R1, R2, R3]
}

// Mode determines whether the mock operates in Handle mode or WhenReturn mode.
func (m *Invoker53[T1, T2, T3, T4, T5, R1, R2, R3]) Mode() Mode {
	if m.fnHandle != nil {
		return ModeHandle
	}
	return ModeWhenReturn
}

// Handle executes the custom function if set.
func (m *Invoker53[T1, T2, T3, T4, T5, R1, R2, R3]) Handle(params []any) []any {
	r1, r2, r3 := m.fnHandle(params[0].(T1), params[1].(T2), params[2].(T3), params[3].(T4), params[4].(T5))
	return []any{r1, r2, r3}
}

// When checks if the condition function evaluates to true.
func (m *Invoker53[T1, T2, T3, T4, T5, R1, R2, R3]) When(params []any) bool {
	if m.fnWhen == nil {
		return false
	}
	return m.fnWhen(params[0].(T1), params[1].(T2), params[2].(T3), params[3].(T4), params[4].(T5))
}

// Return provides predefined response and error values.
func (m *Invoker53[T1, T2, T3, T4, T5, R1, R2, R3]) Return() []any {
	r1, r2, r3 := m.fnReturn()
	return []any{r1, r2, r3}
}

// Mock53 creates a new Mocker53 instance.
func Mock53[T1, T2, T3, T4, T5 any, R1, R2, R3 any](f func(T1, T2, T3, T4, T5) (R1, R2, R3), r *Manager) *Mocker53[T1, T2, T3, T4, T5, R1, R2, R3] {
	PatchOnce(f)
	m := &Mocker53[T1, T2, T3, T4, T5, R1, R2, R3]{}
	i := &Invoker53[T1, T2, T3, T4, T5, R1, R2, R3]{Mocker53: m}
	r.addMocker(f, i)
	return m
}

/******************************** VarMocker53 ***********************************/

type VarMocker53[T1, T2, T3, T4, T5 any, R1, R2, R3 any] struct {
	fnHandle func(T1, T2, T3, T4, []T5) (R1, R2, R3)
	fnWhen   func(T1, T2, T3, T4, []T5) bool
	fnReturn func() (R1, R2, R3)
}

// Handle sets a custom function to handle requests.
func (m *VarMocker53[T1, T2, T3, T4, T5, R1, R2, R3]) Handle(fn func(T1, T2, T3, T4, []T5) (R1, R2, R3)) {
	m.fnHandle = fn
}

// When sets a condition function that determines if the mock should apply.
func (m *VarMocker53[T1, T2, T3, T4, T5, R1, R2, R3]) When(fn func(T1, T2, T3, T4, []T5) bool) *VarMocker53[T1, T2, T3, T4, T5, R1, R2, R3] {
	m.fnWhen = fn
	return m
}

// Return sets a function that returns predefined values.
func (m *VarMocker53[T1, T2, T3, T4, T5, R1, R2, R3]) Return(fn func() (R1, R2, R3)) {
	if m.fnWhen == nil {
		m.fnWhen = func(T1, T2, T3, T4, []T5) bool { return true }
	}
	m.fnReturn = fn
}

// ReturnValue sets a return function with predefined values.
func (m *VarMocker53[T1, T2, T3, T4, T5, R1, R2, R3]) ReturnValue(r1 R1, r2 R2, r3 R3) {
	m.Return(func() (R1, R2, R3) { return r1, r2, r3 })
}

// ReturnDefault sets a return function that returns zero values for all return types.
func (m *VarMocker53[T1, T2, T3, T4, T5, R1, R2, R3]) ReturnDefault() {
	m.Return(func() (r1 R1, r2 R2, r3 R3) { return r1, r2, r3 })
}

// VarInvoker53 is an Invoker implementation for VarMocker53.
type VarInvoker53[T1, T2, T3, T4, T5 any, R1, R2, R3 any] struct {
	*VarMocker53[T1, T2, T3, T4, T5, R1, R2, R3]
}

// Mode determines whether the mock operates in Handle mode or WhenReturn mode.
func (m *VarInvoker53[T1, T2, T3, T4, T5, R1, R2, R3]) Mode() Mode {
	if m.fnHandle != nil {
		return ModeHandle
	}
	return ModeWhenReturn
}

// Handle executes the custom function if set.
func (m *VarInvoker53[T1, T2, T3, T4, T5, R1, R2, R3]) Handle(params []any) []any {
	r1, r2, r3 := m.fnHandle(params[0].(T1), params[1].(T2), params[2].(T3), params[3].(T4), params[4].([]T5))
	return []any{r1, r2, r3}
}

// When checks if the condition function evaluates to true.
func (m *VarInvoker53[T1, T2, T3, T4, T5, R1, R2, R3]) When(params []any) bool {
	if m.fnWhen == nil {
		return false
	}
	return m.fnWhen(params[0].(T1), params[1].(T2), params[2].(T3), params[3].(T4), params[4].([]T5))
}

// Return provides predefined response and error values.
func (m *VarInvoker53[T1, T2, T3, T4, T5, R1, R2, R3]) Return() []any {
	r1, r2, r3 := m.fnReturn()
	return []any{r1, r2, r3}
}

// VarMock53 creates a new VarMocker53 instance.
func VarMock53[T1, T2, T3, T4, T5 any, R1, R2, R3 any](f func(T1, T2, T3, T4, ...T5) (R1, R2, R3), r *Manager) *VarMocker53[T1, T2, T3, T4, T5, R1, R2, R3] {
	PatchOnce(f)
	m := &VarMocker53[T1, T2, T3, T4, T5, R1, R2, R3]{}
	i := &VarInvoker53[T1, T2, T3, T4, T5, R1, R2, R3]{VarMocker53: m}
	r.addMocker(f, i)
	return m
}

/******************************** Mocker54 ***********************************/

type Mocker54[T1, T2, T3, T4, T5 any, R1, R2, R3, R4 any] struct {
	fnHandle func(T1, T2, T3, T4, T5) (R1, R2, R3, R4)
	fnWhen   func(T1, T2, T3, T4, T5) bool
	fnReturn func() (R1, R2, R3, R4)
}

// Handle sets a custom function to handle requests.
func (m *Mocker54[T1, T2, T3, T4, T5, R1, R2, R3, R4]) Handle(fn func(T1, T2, T3, T4, T5) (R1, R2, R3, R4)) {
	m.fnHandle = fn
}

// When sets a condition function that determines if the mock should apply.
func (m *Mocker54[T1, T2, T3, T4, T5, R1, R2, R3, R4]) When(fn func(T1, T2, T3, T4, T5) bool) *Mocker54[T1, T2, T3, T4, T5, R1, R2, R3, R4] {
	m.fnWhen = fn
	return m
}

// Return sets a function that returns predefined values.
func (m *Mocker54[T1, T2, T3, T4, T5, R1, R2, R3, R4]) Return(fn func() (R1, R2, R3, R4)) {
	if m.fnWhen == nil {
		m.fnWhen = func(T1, T2, T3, T4, T5) bool { return true }
	}
	m.fnReturn = fn
}

// ReturnValue sets a return function with predefined values.
func (m *Mocker54[T1, T2, T3, T4, T5, R1, R2, R3, R4]) ReturnValue(r1 R1, r2 R2, r3 R3, r4 R4) {
	m.Return(func() (R1, R2, R3, R4) { return r1, r2, r3, r4 })
}

// ReturnDefault sets a return function that returns zero values for all return types.
func (m *Mocker54[T1, T2, T3, T4, T5, R1, R2, R3, R4]) ReturnDefault() {
	m.Return(func() (r1 R1, r2 R2, r3 R3, r4 R4) { return r1, r2, r3, r4 })
}

// Invoker54 is an Invoker implementation for Mocker54.
type Invoker54[T1, T2, T3, T4, T5 any, R1, R2, R3, R4 any] struct {
	*Mocker54[T1, T2, T3, T4, T5, R1, R2, R3, R4]
}

// Mode determines whether the mock operates in Handle mode or WhenReturn mode.
func (m *Invoker54[T1, T2, T3, T4, T5, R1, R2, R3, R4]) Mode() Mode {
	if m.fnHandle != nil {
		return ModeHandle
	}
	return ModeWhenReturn
}

// Handle executes the custom function if set.
func (m *Invoker54[T1, T2, T3, T4, T5, R1, R2, R3, R4]) Handle(params []any) []any {
	r1, r2, r3, r4 := m.fnHandle(params[0].(T1), params[1].(T2), params[2].(T3), params[3].(T4), params[4].(T5))
	return []any{r1, r2, r3, r4}
}

// When checks if the condition function evaluates to true.
func (m *Invoker54[T1, T2, T3, T4, T5, R1, R2, R3, R4]) When(params []any) bool {
	if m.fnWhen == nil {
		return false
	}
	return m.fnWhen(params[0].(T1), params[1].(T2), params[2].(T3), params[3].(T4), params[4].(T5))
}

// Return provides predefined response and error values.
func (m *Invoker54[T1, T2, T3, T4, T5, R1, R2, R3, R4]) Return() []any {
	r1, r2, r3, r4 := m.fnReturn()
	return []any{r1, r2, r3, r4}
}

// Mock54 creates a new Mocker54 instance.
func Mock54[T1, T2, T3, T4, T5 any, R1, R2, R3, R4 any](f func(T1, T2, T3, T4, T5) (R1, R2, R3, R4), r *Manager) *Mocker54[T1, T2, T3, T4, T5, R1, R2, R3, R4] {
	PatchOnce(f)
	m := &Mocker54[T1, T2, T3, T4, T5, R1, R2, R3, R4]{}
	i := &Invoker54[T1, T2, T3, T4, T5, R1, R2, R3, R4]{Mocker54: m}
	r.addMocker(f, i)
	return m
}

/******************************** VarMocker54 ***********************************/

type VarMocker54[T1, T2, T3, T4, T5 any, R1, R2, R3, R4 any] struct {
	fnHandle func(T1, T2, T3, T4, []T5) (R1, R2, R3, R4)
	fnWhen   func(T1, T2, T3, T4, []T5) bool
	fnReturn func() (R1, R2, R3, R4)
}

// Handle sets a custom function to handle requests.
func (m *VarMocker54[T1, T2, T3, T4, T5, R1, R2, R3, R4]) Handle(fn func(T1, T2, T3, T4, []T5) (R1, R2, R3, R4)) {
	m.fnHandle = fn
}

// When sets a condition function that determines if the mock should apply.
func (m *VarMocker54[T1, T2, T3, T4, T5, R1, R2, R3, R4]) When(fn func(T1, T2, T3, T4, []T5) bool) *VarMocker54[T1, T2, T3, T4, T5, R1, R2, R3, R4] {
	m.fnWhen = fn
	return m
}

// Return sets a function that returns predefined values.
func (m *VarMocker54[T1, T2, T3, T4, T5, R1, R2, R3, R4]) Return(fn func() (R1, R2, R3, R4)) {
	if m.fnWhen == nil {
		m.fnWhen = func(T1, T2, T3, T4, []T5) bool { return true }
	}
	m.fnReturn = fn
}

// ReturnValue sets a return function with predefined values.
func (m *VarMocker54[T1, T2, T3, T4, T5, R1, R2, R3, R4]) ReturnValue(r1 R1, r2 R2, r3 R3, r4 R4) {
	m.Return(func() (R1, R2, R3, R4) { return r1, r2, r3, r4 })
}

// ReturnDefault sets a return function that returns zero values for all return types.
func (m *VarMocker54[T1, T2, T3, T4, T5, R1, R2, R3, R4]) ReturnDefault() {
	m.Return(func() (r1 R1, r2 R2, r3 R3, r4 R4) { return r1, r2, r3, r4 })
}

// VarInvoker54 is an Invoker implementation for VarMocker54.
type VarInvoker54[T1, T2, T3, T4, T5 any, R1, R2, R3, R4 any] struct {
	*VarMocker54[T1, T2, T3, T4, T5, R1, R2, R3, R4]
}

// Mode determines whether the mock operates in Handle mode or WhenReturn mode.
func (m *VarInvoker54[T1, T2, T3, T4, T5, R1, R2, R3, R4]) Mode() Mode {
	if m.fnHandle != nil {
		return ModeHandle
	}
	return ModeWhenReturn
}

// Handle executes the custom function if set.
func (m *VarInvoker54[T1, T2, T3, T4, T5, R1, R2, R3, R4]) Handle(params []any) []any {
	r1, r2, r3, r4 := m.fnHandle(params[0].(T1), params[1].(T2), params[2].(T3), params[3].(T4), params[4].([]T5))
	return []any{r1, r2, r3, r4}
}

// When checks if the condition function evaluates to true.
func (m *VarInvoker54[T1, T2, T3, T4, T5, R1, R2, R3, R4]) When(params []any) bool {
	if m.fnWhen == nil {
		return false
	}
	return m.fnWhen(params[0].(T1), params[1].(T2), params[2].(T3), params[3].(T4), params[4].([]T5))
}

// Return provides predefined response and error values.
func (m *VarInvoker54[T1, T2, T3, T4, T5, R1, R2, R3, R4]) Return() []any {
	r1, r2, r3, r4 := m.fnReturn()
	return []any{r1, r2, r3, r4}
}

// VarMock54 creates a new VarMocker54 instance.
func VarMock54[T1, T2, T3, T4, T5 any, R1, R2, R3, R4 any](f func(T1, T2, T3, T4, ...T5) (R1, R2, R3, R4), r *Manager) *VarMocker54[T1, T2, T3, T4, T5, R1, R2, R3, R4] {
	PatchOnce(f)
	m := &VarMocker54[T1, T2, T3, T4, T5, R1, R2, R3, R4]{}
	i := &VarInvoker54[T1, T2, T3, T4, T5, R1, R2, R3, R4]{VarMocker54: m}
	r.addMocker(f, i)
	return m
}

/******************************** Mocker60 ***********************************/

type Mocker60[T1, T2, T3, T4, T5, T6 any] struct {
	fnHandle func(T1, T2, T3, T4, T5, T6)
	fnWhen   func(T1, T2, T3, T4, T5, T6) bool
	fnReturn func()
}

// Handle sets a custom function to handle requests.
func (m *Mocker60[T1, T2, T3, T4, T5, T6]) Handle(fn func(T1, T2, T3, T4, T5, T6)) {
	m.fnHandle = fn
}

// When sets a condition function that determines if the mock should apply.
func (m *Mocker60[T1, T2, T3, T4, T5, T6]) When(fn func(T1, T2, T3, T4, T5, T6) bool) *Mocker60[T1, T2, T3, T4, T5, T6] {
	m.fnWhen = fn
	return m
}

// Return sets a function that returns predefined values.
func (m *Mocker60[T1, T2, T3, T4, T5, T6]) Return(fn func()) {
	if m.fnWhen == nil {
		m.fnWhen = func(T1, T2, T3, T4, T5, T6) bool { return true }
	}
	m.fnReturn = fn
}

// ReturnValue sets a return function with predefined values.
func (m *Mocker60[T1, T2, T3, T4, T5, T6]) ReturnValue() {
	m.Return(func() {})
}

// ReturnDefault sets a return function that returns zero values for all return types.
func (m *Mocker60[T1, T2, T3, T4, T5, T6]) ReturnDefault() {
	m.Return(func() {})
}

// Invoker60 is an Invoker implementation for Mocker60.
type Invoker60[T1, T2, T3, T4, T5, T6 any] struct {
	*Mocker60[T1, T2, T3, T4, T5, T6]
}

// Mode determines whether the mock operates in Handle mode or WhenReturn mode.
func (m *Invoker60[T1, T2, T3, T4, T5, T6]) Mode() Mode {
	if m.fnHandle != nil {
		return ModeHandle
	}
	return ModeWhenReturn
}

// Handle executes the custom function if set.
func (m *Invoker60[T1, T2, T3, T4, T5, T6]) Handle(params []any) []any {
	m.fnHandle(params[0].(T1), params[1].(T2), params[2].(T3), params[3].(T4), params[4].(T5), params[5].(T6))
	return []any{}
}

// When checks if the condition function evaluates to true.
func (m *Invoker60[T1, T2, T3, T4, T5, T6]) When(params []any) bool {
	if m.fnWhen == nil {
		return false
	}
	return m.fnWhen(params[0].(T1), params[1].(T2), params[2].(T3), params[3].(T4), params[4].(T5), params[5].(T6))
}

// Return provides predefined response and error values.
func (m *Invoker60[T1, T2, T3, T4, T5, T6]) Return() []any {
	m.fnReturn()
	return []any{}
}

// Mock60 creates a new Mocker60 instance.
func Mock60[T1, T2, T3, T4, T5, T6 any](f func(T1, T2, T3, T4, T5, T6), r *Manager) *Mocker60[T1, T2, T3, T4, T5, T6] {
	PatchOnce(f)
	m := &Mocker60[T1, T2, T3, T4, T5, T6]{}
	i := &Invoker60[T1, T2, T3, T4, T5, T6]{Mocker60: m}
	r.addMocker(f, i)
	return m
}

/******************************** VarMocker60 ***********************************/

type VarMocker60[T1, T2, T3, T4, T5, T6 any] struct {
	fnHandle func(T1, T2, T3, T4, T5, []T6)
	fnWhen   func(T1, T2, T3, T4, T5, []T6) bool
	fnReturn func()
}

// Handle sets a custom function to handle requests.
func (m *VarMocker60[T1, T2, T3, T4, T5, T6]) Handle(fn func(T1, T2, T3, T4, T5, []T6)) {
	m.fnHandle = fn
}

// When sets a condition function that determines if the mock should apply.
func (m *VarMocker60[T1, T2, T3, T4, T5, T6]) When(fn func(T1, T2, T3, T4, T5, []T6) bool) *VarMocker60[T1, T2, T3, T4, T5, T6] {
	m.fnWhen = fn
	return m
}

// Return sets a function that returns predefined values.
func (m *VarMocker60[T1, T2, T3, T4, T5, T6]) Return(fn func()) {
	if m.fnWhen == nil {
		m.fnWhen = func(T1, T2, T3, T4, T5, []T6) bool { return true }
	}
	m.fnReturn = fn
}

// ReturnValue sets a return function with predefined values.
func (m *VarMocker60[T1, T2, T3, T4, T5, T6]) ReturnValue() {
	m.Return(func() {})
}

// ReturnDefault sets a return function that returns zero values for all return types.
func (m *VarMocker60[T1, T2, T3, T4, T5, T6]) ReturnDefault() {
	m.Return(func() {})
}

// VarInvoker60 is an Invoker implementation for VarMocker60.
type VarInvoker60[T1, T2, T3, T4, T5, T6 any] struct {
	*VarMocker60[T1, T2, T3, T4, T5, T6]
}

// Mode determines whether the mock operates in Handle mode or WhenReturn mode.
func (m *VarInvoker60[T1, T2, T3, T4, T5, T6]) Mode() Mode {
	if m.fnHandle != nil {
		return ModeHandle
	}
	return ModeWhenReturn
}

// Handle executes the custom function if set.
func (m *VarInvoker60[T1, T2, T3, T4, T5, T6]) Handle(params []any) []any {
	m.fnHandle(params[0].(T1), params[1].(T2), params[2].(T3), params[3].(T4), params[4].(T5), params[5].([]T6))
	return []any{}
}

// When checks if the condition function evaluates to true.
func (m *VarInvoker60[T1, T2, T3, T4, T5, T6]) When(params []any) bool {
	if m.fnWhen == nil {
		return false
	}
	return m.fnWhen(params[0].(T1), params[1].(T2), params[2].(T3), params[3].(T4), params[4].(T5), params[5].([]T6))
}

// Return provides predefined response and error values.
func (m *VarInvoker60[T1, T2, T3, T4, T5, T6]) Return() []any {
	m.fnReturn()
	return []any{}
}

// VarMock60 creates a new VarMocker60 instance.
func VarMock60[T1, T2, T3, T4, T5, T6 any](f func(T1, T2, T3, T4, T5, ...T6), r *Manager) *VarMocker60[T1, T2, T3, T4, T5, T6] {
	PatchOnce(f)
	m := &VarMocker60[T1, T2, T3, T4, T5, T6]{}
	i := &VarInvoker60[T1, T2, T3, T4, T5, T6]{VarMocker60: m}
	r.addMocker(f, i)
	return m
}

/******************************** Mocker61 ***********************************/

type Mocker61[T1, T2, T3, T4, T5, T6 any, R1 any] struct {
	fnHandle func(T1, T2, T3, T4, T5, T6) R1
	fnWhen   func(T1, T2, T3, T4, T5, T6) bool
	fnReturn func() R1
}

// Handle sets a custom function to handle requests.
func (m *Mocker61[T1, T2, T3, T4, T5, T6, R1]) Handle(fn func(T1, T2, T3, T4, T5, T6) R1) {
	m.fnHandle = fn
}

// When sets a condition function that determines if the mock should apply.
func (m *Mocker61[T1, T2, T3, T4, T5, T6, R1]) When(fn func(T1, T2, T3, T4, T5, T6) bool) *Mocker61[T1, T2, T3, T4, T5, T6, R1] {
	m.fnWhen = fn
	return m
}

// Return sets a function that returns predefined values.
func (m *Mocker61[T1, T2, T3, T4, T5, T6, R1]) Return(fn func() R1) {
	if m.fnWhen == nil {
		m.fnWhen = func(T1, T2, T3, T4, T5, T6) bool { return true }
	}
	m.fnReturn = fn
}

// ReturnValue sets a return function with predefined values.
func (m *Mocker61[T1, T2, T3, T4, T5, T6, R1]) ReturnValue(r1 R1) {
	m.Return(func() R1 { return r1 })
}

// ReturnDefault sets a return function that returns zero values for all return types.
func (m *Mocker61[T1, T2, T3, T4, T5, T6, R1]) ReturnDefault() {
	m.Return(func() (r1 R1) { return r1 })
}

// Invoker61 is an Invoker implementation for Mocker61.
type Invoker61[T1, T2, T3, T4, T5, T6 any, R1 any] struct {
	*Mocker61[T1, T2, T3, T4, T5, T6, R1]
}

// Mode determines whether the mock operates in Handle mode or WhenReturn mode.
func (m *Invoker61[T1, T2, T3, T4, T5, T6, R1]) Mode() Mode {
	if m.fnHandle != nil {
		return ModeHandle
	}
	return ModeWhenReturn
}

// Handle executes the custom function if set.
func (m *Invoker61[T1, T2, T3, T4, T5, T6, R1]) Handle(params []any) []any {
	r1 := m.fnHandle(params[0].(T1), params[1].(T2), params[2].(T3), params[3].(T4), params[4].(T5), params[5].(T6))
	return []any{r1}
}

// When checks if the condition function evaluates to true.
func (m *Invoker61[T1, T2, T3, T4, T5, T6, R1]) When(params []any) bool {
	if m.fnWhen == nil {
		return false
	}
	return m.fnWhen(params[0].(T1), params[1].(T2), params[2].(T3), params[3].(T4), params[4].(T5), params[5].(T6))
}

// Return provides predefined response and error values.
func (m *Invoker61[T1, T2, T3, T4, T5, T6, R1]) Return() []any {
	r1 := m.fnReturn()
	return []any{r1}
}

// Mock61 creates a new Mocker61 instance.
func Mock61[T1, T2, T3, T4, T5, T6 any, R1 any](f func(T1, T2, T3, T4, T5, T6) R1, r *Manager) *Mocker61[T1, T2, T3, T4, T5, T6, R1] {
	PatchOnce(f)
	m := &Mocker61[T1, T2, T3, T4, T5, T6, R1]{}
	i := &Invoker61[T1, T2, T3, T4, T5, T6, R1]{Mocker61: m}
	r.addMocker(f, i)
	return m
}

/******************************** VarMocker61 ***********************************/

type VarMocker61[T1, T2, T3, T4, T5, T6 any, R1 any] struct {
	fnHandle func(T1, T2, T3, T4, T5, []T6) R1
	fnWhen   func(T1, T2, T3, T4, T5, []T6) bool
	fnReturn func() R1
}

// Handle sets a custom function to handle requests.
func (m *VarMocker61[T1, T2, T3, T4, T5, T6, R1]) Handle(fn func(T1, T2, T3, T4, T5, []T6) R1) {
	m.fnHandle = fn
}

// When sets a condition function that determines if the mock should apply.
func (m *VarMocker61[T1, T2, T3, T4, T5, T6, R1]) When(fn func(T1, T2, T3, T4, T5, []T6) bool) *VarMocker61[T1, T2, T3, T4, T5, T6, R1] {
	m.fnWhen = fn
	return m
}

// Return sets a function that returns predefined values.
func (m *VarMocker61[T1, T2, T3, T4, T5, T6, R1]) Return(fn func() R1) {
	if m.fnWhen == nil {
		m.fnWhen = func(T1, T2, T3, T4, T5, []T6) bool { return true }
	}
	m.fnReturn = fn
}

// ReturnValue sets a return function with predefined values.
func (m *VarMocker61[T1, T2, T3, T4, T5, T6, R1]) ReturnValue(r1 R1) {
	m.Return(func() R1 { return r1 })
}

// ReturnDefault sets a return function that returns zero values for all return types.
func (m *VarMocker61[T1, T2, T3, T4, T5, T6, R1]) ReturnDefault() {
	m.Return(func() (r1 R1) { return r1 })
}

// VarInvoker61 is an Invoker implementation for VarMocker61.
type VarInvoker61[T1, T2, T3, T4, T5, T6 any, R1 any] struct {
	*VarMocker61[T1, T2, T3, T4, T5, T6, R1]
}

// Mode determines whether the mock operates in Handle mode or WhenReturn mode.
func (m *VarInvoker61[T1, T2, T3, T4, T5, T6, R1]) Mode() Mode {
	if m.fnHandle != nil {
		return ModeHandle
	}
	return ModeWhenReturn
}

// Handle executes the custom function if set.
func (m *VarInvoker61[T1, T2, T3, T4, T5, T6, R1]) Handle(params []any) []any {
	r1 := m.fnHandle(params[0].(T1), params[1].(T2), params[2].(T3), params[3].(T4), params[4].(T5), params[5].([]T6))
	return []any{r1}
}

// When checks if the condition function evaluates to true.
func (m *VarInvoker61[T1, T2, T3, T4, T5, T6, R1]) When(params []any) bool {
	if m.fnWhen == nil {
		return false
	}
	return m.fnWhen(params[0].(T1), params[1].(T2), params[2].(T3), params[3].(T4), params[4].(T5), params[5].([]T6))
}

// Return provides predefined response and error values.
func (m *VarInvoker61[T1, T2, T3, T4, T5, T6, R1]) Return() []any {
	r1 := m.fnReturn()
	return []any{r1}
}

// VarMock61 creates a new VarMocker61 instance.
func VarMock61[T1, T2, T3, T4, T5, T6 any, R1 any](f func(T1, T2, T3, T4, T5, ...T6) R1, r *Manager) *VarMocker61[T1, T2, T3, T4, T5, T6, R1] {
	PatchOnce(f)
	m := &VarMocker61[T1, T2, T3, T4, T5, T6, R1]{}
	i := &VarInvoker61[T1, T2, T3, T4, T5, T6, R1]{VarMocker61: m}
	r.addMocker(f, i)
	return m
}

/******************************** Mocker62 ***********************************/

type Mocker62[T1, T2, T3, T4, T5, T6 any, R1, R2 any] struct {
	fnHandle func(T1, T2, T3, T4, T5, T6) (R1, R2)
	fnWhen   func(T1, T2, T3, T4, T5, T6) bool
	fnReturn func() (R1, R2)
}

// Handle sets a custom function to handle requests.
func (m *Mocker62[T1, T2, T3, T4, T5, T6, R1, R2]) Handle(fn func(T1, T2, T3, T4, T5, T6) (R1, R2)) {
	m.fnHandle = fn
}

// When sets a condition function that determines if the mock should apply.
func (m *Mocker62[T1, T2, T3, T4, T5, T6, R1, R2]) When(fn func(T1, T2, T3, T4, T5, T6) bool) *Mocker62[T1, T2, T3, T4, T5, T6, R1, R2] {
	m.fnWhen = fn
	return m
}

// Return sets a function that returns predefined values.
func (m *Mocker62[T1, T2, T3, T4, T5, T6, R1, R2]) Return(fn func() (R1, R2)) {
	if m.fnWhen == nil {
		m.fnWhen = func(T1, T2, T3, T4, T5, T6) bool { return true }
	}
	m.fnReturn = fn
}

// ReturnValue sets a return function with predefined values.
func (m *Mocker62[T1, T2, T3, T4, T5, T6, R1, R2]) ReturnValue(r1 R1, r2 R2) {
	m.Return(func() (R1, R2) { return r1, r2 })
}

// ReturnDefault sets a return function that returns zero values for all return types.
func (m *Mocker62[T1, T2, T3, T4, T5, T6, R1, R2]) ReturnDefault() {
	m.Return(func() (r1 R1, r2 R2) { return r1, r2 })
}

// Invoker62 is an Invoker implementation for Mocker62.
type Invoker62[T1, T2, T3, T4, T5, T6 any, R1, R2 any] struct {
	*Mocker62[T1, T2, T3, T4, T5, T6, R1, R2]
}

// Mode determines whether the mock operates in Handle mode or WhenReturn mode.
func (m *Invoker62[T1, T2, T3, T4, T5, T6, R1, R2]) Mode() Mode {
	if m.fnHandle != nil {
		return ModeHandle
	}
	return ModeWhenReturn
}

// Handle executes the custom function if set.
func (m *Invoker62[T1, T2, T3, T4, T5, T6, R1, R2]) Handle(params []any) []any {
	r1, r2 := m.fnHandle(params[0].(T1), params[1].(T2), params[2].(T3), params[3].(T4), params[4].(T5), params[5].(T6))
	return []any{r1, r2}
}

// When checks if the condition function evaluates to true.
func (m *Invoker62[T1, T2, T3, T4, T5, T6, R1, R2]) When(params []any) bool {
	if m.fnWhen == nil {
		return false
	}
	return m.fnWhen(params[0].(T1), params[1].(T2), params[2].(T3), params[3].(T4), params[4].(T5), params[5].(T6))
}

// Return provides predefined response and error values.
func (m *Invoker62[T1, T2, T3, T4, T5, T6, R1, R2]) Return() []any {
	r1, r2 := m.fnReturn()
	return []any{r1, r2}
}

// Mock62 creates a new Mocker62 instance.
func Mock62[T1, T2, T3, T4, T5, T6 any, R1, R2 any](f func(T1, T2, T3, T4, T5, T6) (R1, R2), r *Manager) *Mocker62[T1, T2, T3, T4, T5, T6, R1, R2] {
	PatchOnce(f)
	m := &Mocker62[T1, T2, T3, T4, T5, T6, R1, R2]{}
	i := &Invoker62[T1, T2, T3, T4, T5, T6, R1, R2]{Mocker62: m}
	r.addMocker(f, i)
	return m
}

/******************************** VarMocker62 ***********************************/

type VarMocker62[T1, T2, T3, T4, T5, T6 any, R1, R2 any] struct {
	fnHandle func(T1, T2, T3, T4, T5, []T6) (R1, R2)
	fnWhen   func(T1, T2, T3, T4, T5, []T6) bool
	fnReturn func() (R1, R2)
}

// Handle sets a custom function to handle requests.
func (m *VarMocker62[T1, T2, T3, T4, T5, T6, R1, R2]) Handle(fn func(T1, T2, T3, T4, T5, []T6) (R1, R2)) {
	m.fnHandle = fn
}

// When sets a condition function that determines if the mock should apply.
func (m *VarMocker62[T1, T2, T3, T4, T5, T6, R1, R2]) When(fn func(T1, T2, T3, T4, T5, []T6) bool) *VarMocker62[T1, T2, T3, T4, T5, T6, R1, R2] {
	m.fnWhen = fn
	return m
}

// Return sets a function that returns predefined values.
func (m *VarMocker62[T1, T2, T3, T4, T5, T6, R1, R2]) Return(fn func() (R1, R2)) {
	if m.fnWhen == nil {
		m.fnWhen = func(T1, T2, T3, T4, T5, []T6) bool { return true }
	}
	m.fnReturn = fn
}

// ReturnValue sets a return function with predefined values.
func (m *VarMocker62[T1, T2, T3, T4, T5, T6, R1, R2]) ReturnValue(r1 R1, r2 R2) {
	m.Return(func() (R1, R2) { return r1, r2 })
}

// ReturnDefault sets a return function that returns zero values for all return types.
func (m *VarMocker62[T1, T2, T3, T4, T5, T6, R1, R2]) ReturnDefault() {
	m.Return(func() (r1 R1, r2 R2) { return r1, r2 })
}

// VarInvoker62 is an Invoker implementation for VarMocker62.
type VarInvoker62[T1, T2, T3, T4, T5, T6 any, R1, R2 any] struct {
	*VarMocker62[T1, T2, T3, T4, T5, T6, R1, R2]
}

// Mode determines whether the mock operates in Handle mode or WhenReturn mode.
func (m *VarInvoker62[T1, T2, T3, T4, T5, T6, R1, R2]) Mode() Mode {
	if m.fnHandle != nil {
		return ModeHandle
	}
	return ModeWhenReturn
}

// Handle executes the custom function if set.
func (m *VarInvoker62[T1, T2, T3, T4, T5, T6, R1, R2]) Handle(params []any) []any {
	r1, r2 := m.fnHandle(params[0].(T1), params[1].(T2), params[2].(T3), params[3].(T4), params[4].(T5), params[5].([]T6))
	return []any{r1, r2}
}

// When checks if the condition function evaluates to true.
func (m *VarInvoker62[T1, T2, T3, T4, T5, T6, R1, R2]) When(params []any) bool {
	if m.fnWhen == nil {
		return false
	}
	return m.fnWhen(params[0].(T1), params[1].(T2), params[2].(T3), params[3].(T4), params[4].(T5), params[5].([]T6))
}

// Return provides predefined response and error values.
func (m *VarInvoker62[T1, T2, T3, T4, T5, T6, R1, R2]) Return() []any {
	r1, r2 := m.fnReturn()
	return []any{r1, r2}
}

// VarMock62 creates a new VarMocker62 instance.
func VarMock62[T1, T2, T3, T4, T5, T6 any, R1, R2 any](f func(T1, T2, T3, T4, T5, ...T6) (R1, R2), r *Manager) *VarMocker62[T1, T2, T3, T4, T5, T6, R1, R2] {
	PatchOnce(f)
	m := &VarMocker62[T1, T2, T3, T4, T5, T6, R1, R2]{}
	i := &VarInvoker62[T1, T2, T3, T4, T5, T6, R1, R2]{VarMocker62: m}
	r.addMocker(f, i)
	return m
}

/******************************** Mocker63 ***********************************/

type Mocker63[T1, T2, T3, T4, T5, T6 any, R1, R2, R3 any] struct {
	fnHandle func(T1, T2, T3, T4, T5, T6) (R1, R2, R3)
	fnWhen   func(T1, T2, T3, T4, T5, T6) bool
	fnReturn func() (R1, R2, R3)
}

// Handle sets a custom function to handle requests.
func (m *Mocker63[T1, T2, T3, T4, T5, T6, R1, R2, R3]) Handle(fn func(T1, T2, T3, T4, T5, T6) (R1, R2, R3)) {
	m.fnHandle = fn
}

// When sets a condition function that determines if the mock should apply.
func (m *Mocker63[T1, T2, T3, T4, T5, T6, R1, R2, R3]) When(fn func(T1, T2, T3, T4, T5, T6) bool) *Mocker63[T1, T2, T3, T4, T5, T6, R1, R2, R3] {
	m.fnWhen = fn
	return m
}

// Return sets a function that returns predefined values.
func (m *Mocker63[T1, T2, T3, T4, T5, T6, R1, R2, R3]) Return(fn func() (R1, R2, R3)) {
	if m.fnWhen == nil {
		m.fnWhen = func(T1, T2, T3, T4, T5, T6) bool { return true }
	}
	m.fnReturn = fn
}

// ReturnValue sets a return function with predefined values.
func (m *Mocker63[T1, T2, T3, T4, T5, T6, R1, R2, R3]) ReturnValue(r1 R1, r2 R2, r3 R3) {
	m.Return(func() (R1, R2, R3) { return r1, r2, r3 })
}

// ReturnDefault sets a return function that returns zero values for all return types.
func (m *Mocker63[T1, T2, T3, T4, T5, T6, R1, R2, R3]) ReturnDefault() {
	m.Return(func() (r1 R1, r2 R2, r3 R3) { return r1, r2, r3 })
}

// Invoker63 is an Invoker implementation for Mocker63.
type Invoker63[T1, T2, T3, T4, T5, T6 any, R1, R2, R3 any] struct {
	*Mocker63[T1, T2, T3, T4, T5, T6, R1, R2, R3]
}

// Mode determines whether the mock operates in Handle mode or WhenReturn mode.
func (m *Invoker63[T1, T2, T3, T4, T5, T6, R1, R2, R3]) Mode() Mode {
	if m.fnHandle != nil {
		return ModeHandle
	}
	return ModeWhenReturn
}

// Handle executes the custom function if set.
func (m *Invoker63[T1, T2, T3, T4, T5, T6, R1, R2, R3]) Handle(params []any) []any {
	r1, r2, r3 := m.fnHandle(params[0].(T1), params[1].(T2), params[2].(T3), params[3].(T4), params[4].(T5), params[5].(T6))
	return []any{r1, r2, r3}
}

// When checks if the condition function evaluates to true.
func (m *Invoker63[T1, T2, T3, T4, T5, T6, R1, R2, R3]) When(params []any) bool {
	if m.fnWhen == nil {
		return false
	}
	return m.fnWhen(params[0].(T1), params[1].(T2), params[2].(T3), params[3].(T4), params[4].(T5), params[5].(T6))
}

// Return provides predefined response and error values.
func (m *Invoker63[T1, T2, T3, T4, T5, T6, R1, R2, R3]) Return() []any {
	r1, r2, r3 := m.fnReturn()
	return []any{r1, r2, r3}
}

// Mock63 creates a new Mocker63 instance.
func Mock63[T1, T2, T3, T4, T5, T6 any, R1, R2, R3 any](f func(T1, T2, T3, T4, T5, T6) (R1, R2, R3), r *Manager) *Mocker63[T1, T2, T3, T4, T5, T6, R1, R2, R3] {
	PatchOnce(f)
	m := &Mocker63[T1, T2, T3, T4, T5, T6, R1, R2, R3]{}
	i := &Invoker63[T1, T2, T3, T4, T5, T6, R1, R2, R3]{Mocker63: m}
	r.addMocker(f, i)
	return m
}

/******************************** VarMocker63 ***********************************/

type VarMocker63[T1, T2, T3, T4, T5, T6 any, R1, R2, R3 any] struct {
	fnHandle func(T1, T2, T3, T4, T5, []T6) (R1, R2, R3)
	fnWhen   func(T1, T2, T3, T4, T5, []T6) bool
	fnReturn func() (R1, R2, R3)
}

// Handle sets a custom function to handle requests.
func (m *VarMocker63[T1, T2, T3, T4, T5, T6, R1, R2, R3]) Handle(fn func(T1, T2, T3, T4, T5, []T6) (R1, R2, R3)) {
	m.fnHandle = fn
}

// When sets a condition function that determines if the mock should apply.
func (m *VarMocker63[T1, T2, T3, T4, T5, T6, R1, R2, R3]) When(fn func(T1, T2, T3, T4, T5, []T6) bool) *VarMocker63[T1, T2, T3, T4, T5, T6, R1, R2, R3] {
	m.fnWhen = fn
	return m
}

// Return sets a function that returns predefined values.
func (m *VarMocker63[T1, T2, T3, T4, T5, T6, R1, R2, R3]) Return(fn func() (R1, R2, R3)) {
	if m.fnWhen == nil {
		m.fnWhen = func(T1, T2, T3, T4, T5, []T6) bool { return true }
	}
	m.fnReturn = fn
}

// ReturnValue sets a return function with predefined values.
func (m *VarMocker63[T1, T2, T3, T4, T5, T6, R1, R2, R3]) ReturnValue(r1 R1, r2 R2, r3 R3) {
	m.Return(func() (R1, R2, R3) { return r1, r2, r3 })
}

// ReturnDefault sets a return function that returns zero values for all return types.
func (m *VarMocker63[T1, T2, T3, T4, T5, T6, R1, R2, R3]) ReturnDefault() {
	m.Return(func() (r1 R1, r2 R2, r3 R3) { return r1, r2, r3 })
}

// VarInvoker63 is an Invoker implementation for VarMocker63.
type VarInvoker63[T1, T2, T3, T4, T5, T6 any, R1, R2, R3 any] struct {
	*VarMocker63[T1, T2, T3, T4, T5, T6, R1, R2, R3]
}

// Mode determines whether the mock operates in Handle mode or WhenReturn mode.
func (m *VarInvoker63[T1, T2, T3, T4, T5, T6, R1, R2, R3]) Mode() Mode {
	if m.fnHandle != nil {
		return ModeHandle
	}
	return ModeWhenReturn
}

// Handle executes the custom function if set.
func (m *VarInvoker63[T1, T2, T3, T4, T5, T6, R1, R2, R3]) Handle(params []any) []any {
	r1, r2, r3 := m.fnHandle(params[0].(T1), params[1].(T2), params[2].(T3), params[3].(T4), params[4].(T5), params[5].([]T6))
	return []any{r1, r2, r3}
}

// When checks if the condition function evaluates to true.
func (m *VarInvoker63[T1, T2, T3, T4, T5, T6, R1, R2, R3]) When(params []any) bool {
	if m.fnWhen == nil {
		return false
	}
	return m.fnWhen(params[0].(T1), params[1].(T2), params[2].(T3), params[3].(T4), params[4].(T5), params[5].([]T6))
}

// Return provides predefined response and error values.
func (m *VarInvoker63[T1, T2, T3, T4, T5, T6, R1, R2, R3]) Return() []any {
	r1, r2, r3 := m.fnReturn()
	return []any{r1, r2, r3}
}

// VarMock63 creates a new VarMocker63 instance.
func VarMock63[T1, T2, T3, T4, T5, T6 any, R1, R2, R3 any](f func(T1, T2, T3, T4, T5, ...T6) (R1, R2, R3), r *Manager) *VarMocker63[T1, T2, T3, T4, T5, T6, R1, R2, R3] {
	PatchOnce(f)
	m := &VarMocker63[T1, T2, T3, T4, T5, T6, R1, R2, R3]{}
	i := &VarInvoker63[T1, T2, T3, T4, T5, T6, R1, R2, R3]{VarMocker63: m}
	r.addMocker(f, i)
	return m
}

/******************************** Mocker64 ***********************************/

type Mocker64[T1, T2, T3, T4, T5, T6 any, R1, R2, R3, R4 any] struct {
	fnHandle func(T1, T2, T3, T4, T5, T6) (R1, R2, R3, R4)
	fnWhen   func(T1, T2, T3, T4, T5, T6) bool
	fnReturn func() (R1, R2, R3, R4)
}

// Handle sets a custom function to handle requests.
func (m *Mocker64[T1, T2, T3, T4, T5, T6, R1, R2, R3, R4]) Handle(fn func(T1, T2, T3, T4, T5, T6) (R1, R2, R3, R4)) {
	m.fnHandle = fn
}

// When sets a condition function that determines if the mock should apply.
func (m *Mocker64[T1, T2, T3, T4, T5, T6, R1, R2, R3, R4]) When(fn func(T1, T2, T3, T4, T5, T6) bool) *Mocker64[T1, T2, T3, T4, T5, T6, R1, R2, R3, R4] {
	m.fnWhen = fn
	return m
}

// Return sets a function that returns predefined values.
func (m *Mocker64[T1, T2, T3, T4, T5, T6, R1, R2, R3, R4]) Return(fn func() (R1, R2, R3, R4)) {
	if m.fnWhen == nil {
		m.fnWhen = func(T1, T2, T3, T4, T5, T6) bool { return true }
	}
	m.fnReturn = fn
}

// ReturnValue sets a return function with predefined values.
func (m *Mocker64[T1, T2, T3, T4, T5, T6, R1, R2, R3, R4]) ReturnValue(r1 R1, r2 R2, r3 R3, r4 R4) {
	m.Return(func() (R1, R2, R3, R4) { return r1, r2, r3, r4 })
}

// ReturnDefault sets a return function that returns zero values for all return types.
func (m *Mocker64[T1, T2, T3, T4, T5, T6, R1, R2, R3, R4]) ReturnDefault() {
	m.Return(func() (r1 R1, r2 R2, r3 R3, r4 R4) { return r1, r2, r3, r4 })
}

// Invoker64 is an Invoker implementation for Mocker64.
type Invoker64[T1, T2, T3, T4, T5, T6 any, R1, R2, R3, R4 any] struct {
	*Mocker64[T1, T2, T3, T4, T5, T6, R1, R2, R3, R4]
}

// Mode determines whether the mock operates in Handle mode or WhenReturn mode.
func (m *Invoker64[T1, T2, T3, T4, T5, T6, R1, R2, R3, R4]) Mode() Mode {
	if m.fnHandle != nil {
		return ModeHandle
	}
	return ModeWhenReturn
}

// Handle executes the custom function if set.
func (m *Invoker64[T1, T2, T3, T4, T5, T6, R1, R2, R3, R4]) Handle(params []any) []any {
	r1, r2, r3, r4 := m.fnHandle(params[0].(T1), params[1].(T2), params[2].(T3), params[3].(T4), params[4].(T5), params[5].(T6))
	return []any{r1, r2, r3, r4}
}

// When checks if the condition function evaluates to true.
func (m *Invoker64[T1, T2, T3, T4, T5, T6, R1, R2, R3, R4]) When(params []any) bool {
	if m.fnWhen == nil {
		return false
	}
	return m.fnWhen(params[0].(T1), params[1].(T2), params[2].(T3), params[3].(T4), params[4].(T5), params[5].(T6))
}

// Return provides predefined response and error values.
func (m *Invoker64[T1, T2, T3, T4, T5, T6, R1, R2, R3, R4]) Return() []any {
	r1, r2, r3, r4 := m.fnReturn()
	return []any{r1, r2, r3, r4}
}

// Mock64 creates a new Mocker64 instance.
func Mock64[T1, T2, T3, T4, T5, T6 any, R1, R2, R3, R4 any](f func(T1, T2, T3, T4, T5, T6) (R1, R2, R3, R4), r *Manager) *Mocker64[T1, T2, T3, T4, T5, T6, R1, R2, R3, R4] {
	PatchOnce(f)
	m := &Mocker64[T1, T2, T3, T4, T5, T6, R1, R2, R3, R4]{}
	i := &Invoker64[T1, T2, T3, T4, T5, T6, R1, R2, R3, R4]{Mocker64: m}
	r.addMocker(f, i)
	return m
}

/******************************** VarMocker64 ***********************************/

type VarMocker64[T1, T2, T3, T4, T5, T6 any, R1, R2, R3, R4 any] struct {
	fnHandle func(T1, T2, T3, T4, T5, []T6) (R1, R2, R3, R4)
	fnWhen   func(T1, T2, T3, T4, T5, []T6) bool
	fnReturn func() (R1, R2, R3, R4)
}

// Handle sets a custom function to handle requests.
func (m *VarMocker64[T1, T2, T3, T4, T5, T6, R1, R2, R3, R4]) Handle(fn func(T1, T2, T3, T4, T5, []T6) (R1, R2, R3, R4)) {
	m.fnHandle = fn
}

// When sets a condition function that determines if the mock should apply.
func (m *VarMocker64[T1, T2, T3, T4, T5, T6, R1, R2, R3, R4]) When(fn func(T1, T2, T3, T4, T5, []T6) bool) *VarMocker64[T1, T2, T3, T4, T5, T6, R1, R2, R3, R4] {
	m.fnWhen = fn
	return m
}

// Return sets a function that returns predefined values.
func (m *VarMocker64[T1, T2, T3, T4, T5, T6, R1, R2, R3, R4]) Return(fn func() (R1, R2, R3, R4)) {
	if m.fnWhen == nil {
		m.fnWhen = func(T1, T2, T3, T4, T5, []T6) bool { return true }
	}
	m.fnReturn = fn
}

// ReturnValue sets a return function with predefined values.
func (m *VarMocker64[T1, T2, T3, T4, T5, T6, R1, R2, R3, R4]) ReturnValue(r1 R1, r2 R2, r3 R3, r4 R4) {
	m.Return(func() (R1, R2, R3, R4) { return r1, r2, r3, r4 })
}

// ReturnDefault sets a return function that returns zero values for all return types.
func (m *VarMocker64[T1, T2, T3, T4, T5, T6, R1, R2, R3, R4]) ReturnDefault() {
	m.Return(func() (r1 R1, r2 R2, r3 R3, r4 R4) { return r1, r2, r3, r4 })
}

// VarInvoker64 is an Invoker implementation for VarMocker64.
type VarInvoker64[T1, T2, T3, T4, T5, T6 any, R1, R2, R3, R4 any] struct {
	*VarMocker64[T1, T2, T3, T4, T5, T6, R1, R2, R3, R4]
}

// Mode determines whether the mock operates in Handle mode or WhenReturn mode.
func (m *VarInvoker64[T1, T2, T3, T4, T5, T6, R1, R2, R3, R4]) Mode() Mode {
	if m.fnHandle != nil {
		return ModeHandle
	}
	return ModeWhenReturn
}

// Handle executes the custom function if set.
func (m *VarInvoker64[T1, T2, T3, T4, T5, T6, R1, R2, R3, R4]) Handle(params []any) []any {
	r1, r2, r3, r4 := m.fnHandle(params[0].(T1), params[1].(T2), params[2].(T3), params[3].(T4), params[4].(T5), params[5].([]T6))
	return []any{r1, r2, r3, r4}
}

// When checks if the condition function evaluates to true.
func (m *VarInvoker64[T1, T2, T3, T4, T5, T6, R1, R2, R3, R4]) When(params []any) bool {
	if m.fnWhen == nil {
		return false
	}
	return m.fnWhen(params[0].(T1), params[1].(T2), params[2].(T3), params[3].(T4), params[4].(T5), params[5].([]T6))
}

// Return provides predefined response and error values.
func (m *VarInvoker64[T1, T2, T3, T4, T5, T6, R1, R2, R3, R4]) Return() []any {
	r1, r2, r3, r4 := m.fnReturn()
	return []any{r1, r2, r3, r4}
}

// VarMock64 creates a new VarMocker64 instance.
func VarMock64[T1, T2, T3, T4, T5, T6 any, R1, R2, R3, R4 any](f func(T1, T2, T3, T4, T5, ...T6) (R1, R2, R3, R4), r *Manager) *VarMocker64[T1, T2, T3, T4, T5, T6, R1, R2, R3, R4] {
	PatchOnce(f)
	m := &VarMocker64[T1, T2, T3, T4, T5, T6, R1, R2, R3, R4]{}
	i := &VarInvoker64[T1, T2, T3, T4, T5, T6, R1, R2, R3, R4]{VarMocker64: m}
	r.addMocker(f, i)
	return m
}
