/*
 * Copyright 2025 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package main

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"runtime"
	"strings"
)

// init sets the working directory of the program to the directory
// where this source file resides. This ensures that relative paths
// used later in the program (e.g., for output) are resolved correctly.
func init() {
	_, filename, _, ok := runtime.Caller(0)
	if !ok {
		panic("cannot determine caller directory")
	}
	execDir := filepath.Dir(filename)
	err := os.Chdir(execDir)
	if err != nil {
		panic(err)
	}
	workDir, err := os.Getwd()
	if err != nil {
		panic(err)
	}
	fmt.Println("working directory:", workDir)
}

func main() {
	s := bytes.NewBuffer(nil)

	// Write the file header.
	s.WriteString(`
	// Code generated by internal/mocker. DO NOT EDIT.

	package gsmock
	`)

	const (
		MaxParamCount  = 7
		MaxResultCount = 4
	)

	// Write these constants into the generated file.
	s.WriteString(fmt.Sprintf(`
	const (
		MaxParamCount  = %d
		MaxResultCount = %d
	)
	`, MaxParamCount, MaxResultCount))

	for i := 0; i <= MaxParamCount; i++ {
		for j := 0; j <= MaxResultCount; j++ {
			mockerName := fmt.Sprintf("Mocker%d%d", i, j)
			invokerName := fmt.Sprintf("Invoker%d%d", i, j)
			funcMockName := fmt.Sprintf("Func%d%d", i, j)
			methodMockName := fmt.Sprintf("Method%d%d", i, j)

			varMockerName := fmt.Sprintf("VarMocker%d%d", i, j)
			varInvokerName := fmt.Sprintf("VarInvoker%d%d", i, j)
			varFuncMockName := fmt.Sprintf("VarFunc%d%d", i, j)
			varMethodMockName := fmt.Sprintf("VarMethod%d%d", i, j)

			reqArray := make([]string, i)
			varReqArray := make([]string, i)
			funcReqArray := make([]string, i)
			varFuncReqArray := make([]string, i)
			for k := 0; k < i; k++ {
				reqArray[k] = fmt.Sprintf("T%d", k+1)
				varReqArray[k] = fmt.Sprintf("T%d", k+1)
				funcReqArray[k] = fmt.Sprintf("T%d", k+1)
				varFuncReqArray[k] = fmt.Sprintf("T%d", k+1)
				if k == i-1 {
					varReqArray[k] = "[]" + varReqArray[k]
					varFuncReqArray[k] = "..." + varFuncReqArray[k]
				}
			}

			// Build type parameter lists for request and response types.
			respArray := make([]string, j)
			respVars := make([]string, j)
			respParams := make([]string, j)
			for k := 0; k < j; k++ {
				respArray[k] = fmt.Sprintf("R%d", k+1)
				respVars[k] = fmt.Sprintf("r%d", k+1)
				respParams[k] = respVars[k] + " " + respArray[k]
			}

			typeArgs := ""
			typeParams := ""
			if len(reqArray) > 0 {
				typeArgs += strings.Join(reqArray, ", ")
				typeParams += strings.Join(reqArray, ", ") + " any"
			}
			if len(respArray) > 0 {
				if typeArgs != "" {
					typeArgs += ", "
					typeParams += ", "
				}
				typeArgs += strings.Join(respArray, ", ")
				typeParams += strings.Join(respArray, ", ") + " any"
			}
			if typeArgs != "" {
				typeArgs = "[" + typeArgs + "]"
			}
			if typeParams != "" {
				typeParams = "[" + typeParams + "]"
			}

			// Build type assertions for converting []any to typed arguments.
			invokerArgs := make([]string, i)
			varInvokerArgs := make([]string, i)
			for k := 0; k < i; k++ {
				invokerArgs[k] = fmt.Sprintf("params[%d].(T%d)", k, k+1)
				if k < i-1 {
					varInvokerArgs[k] = fmt.Sprintf("params[%d].(T%d)", k, k+1)
				} else {
					varInvokerArgs[k] = fmt.Sprintf("params[%d].([]T%d)", k, k+1)
				}
			}

			req := strings.Join(reqArray, ", ")
			resp := strings.Join(respArray, ", ")
			if resp != "" {
				resp = "(" + resp + ")"
			}

			varReq := strings.Join(varReqArray, ", ")
			varResp := strings.Join(respArray, ", ")
			if varResp != "" {
				varResp = "(" + varResp + ")"
			}

			// Prepare template data.
			data := map[string]any{
				"mockerName":     mockerName,
				"invokerName":    invokerName,
				"typeArgs":       typeArgs,
				"typeParams":     typeParams,
				"funcMockName":   funcMockName,
				"methodMockName": methodMockName,
				"req":            req,
				"funcReq":        strings.Join(funcReqArray, ", "),
				"resp":           resp,
				"respVars":       strings.Join(respVars, ", "),
				"respParams":     strings.Join(respParams, ", "),
				"invokerArgs":    strings.Join(invokerArgs, ", "),
			}

			// Execute the appropriate template for this (i, j).
			if err := tmplMock.Execute(s, data); err != nil {
				panic(fmt.Errorf("error executing template(%s): %w", mockerName, err))
			}

			// Prepare template data.
			data = map[string]any{
				"mockerName":     varMockerName,
				"invokerName":    varInvokerName,
				"typeArgs":       typeArgs,
				"typeParams":     typeParams,
				"funcMockName":   varFuncMockName,
				"methodMockName": varMethodMockName,
				"req":            varReq,
				"funcReq":        strings.Join(varFuncReqArray, ", "),
				"resp":           varResp,
				"respVars":       strings.Join(respVars, ", "),
				"respParams":     strings.Join(respParams, ", "),
				"invokerArgs":    strings.Join(varInvokerArgs, ", "),
			}

			// Execute the appropriate template for this (i, j).
			if err := tmplMock.Execute(s, data); err != nil {
				panic(fmt.Errorf("error executing template(%s): %w", varMockerName, err))
			}
		}
	}

	// Format the generated code using go/format.
	b, err := format.Source(s.Bytes())
	if err != nil {
		panic(fmt.Errorf("error formatting source code: %w", err))
	}

	// Write the formatted code to the output file.
	const fileName = "../../gsmock/mocker.go"
	err = os.WriteFile(fileName, b, os.ModePerm)
	if err != nil {
		panic(fmt.Errorf("error writing file(%s): %w", fileName, err))
	}
}
