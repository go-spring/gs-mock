// Code generated by gsmock v0.0.1. DO NOT EDIT.
// Source: https://github.com/go-spring/gs-mock
// gs-mock -o src_mock.go -i '!RepositoryV2,,GenericService,Service,,Repository'

package example

import (
	"context"
	exp "github.com/go-spring/gs-mock/example/inner"
	"github.com/go-spring/gs-mock/gsmock"
	"io"
	"net/http"
	"reflect"
)

type RepositoryMockImpl[T ~int | ~uint, M *http.Request] struct {
	r *gsmock.Manager
}

func NewRepositoryMockImpl[T ~int | ~uint, M *http.Request](r *gsmock.Manager) *RepositoryMockImpl[T, M] {
	return &RepositoryMockImpl[T, M]{r: r}
}

func (impl *RepositoryMockImpl[T, M]) FindByID(id string) (T, error) {
	t := reflect.TypeFor[RepositoryMockImpl[T, M]]()
	if ret, ok := gsmock.Invoke(impl.r, t, "FindByID", id); ok {
		return gsmock.Unbox2[T, error](ret)
	}
	panic("no mock code matched")
}

func (impl *RepositoryMockImpl[T, M]) MockFindByID() *gsmock.Mocker12[string, T, error] {
	t := reflect.TypeFor[RepositoryMockImpl[T, M]]()
	return gsmock.NewMocker12[string, T, error](impl.r, t, "FindByID")
}

func (impl *RepositoryMockImpl[T, M]) Save(item T) error {
	t := reflect.TypeFor[RepositoryMockImpl[T, M]]()
	if ret, ok := gsmock.Invoke(impl.r, t, "Save", item); ok {
		return gsmock.Unbox1[error](ret)
	}
	panic("no mock code matched")
}

func (impl *RepositoryMockImpl[T, M]) MockSave() *gsmock.Mocker11[T, error] {
	t := reflect.TypeFor[RepositoryMockImpl[T, M]]()
	return gsmock.NewMocker11[T, error](impl.r, t, "Save")
}

type GenericServiceMockImpl[T any, R any] struct {
	io.Writer

	r *gsmock.Manager
}

func NewGenericServiceMockImpl[T any, R any](r *gsmock.Manager) *GenericServiceMockImpl[T, R] {
	return &GenericServiceMockImpl[T, R]{r: r}
}

func (impl *GenericServiceMockImpl[T, R]) M00() {
	t := reflect.TypeFor[GenericServiceMockImpl[T, R]]()
	if _, ok := gsmock.Invoke(impl.r, t, "M00"); ok {
		return
	}
	panic("no mock code matched")
}

func (impl *GenericServiceMockImpl[T, R]) MockM00() *gsmock.Mocker00 {
	t := reflect.TypeFor[GenericServiceMockImpl[T, R]]()
	return gsmock.NewMocker00(impl.r, t, "M00")
}

func (impl *GenericServiceMockImpl[T, R]) M01() R {
	t := reflect.TypeFor[GenericServiceMockImpl[T, R]]()
	if ret, ok := gsmock.Invoke(impl.r, t, "M01"); ok {
		return gsmock.Unbox1[R](ret)
	}
	panic("no mock code matched")
}

func (impl *GenericServiceMockImpl[T, R]) MockM01() *gsmock.Mocker01[R] {
	t := reflect.TypeFor[GenericServiceMockImpl[T, R]]()
	return gsmock.NewMocker01[R](impl.r, t, "M01")
}

func (impl *GenericServiceMockImpl[T, R]) M10(r0 T) {
	t := reflect.TypeFor[GenericServiceMockImpl[T, R]]()
	if _, ok := gsmock.Invoke(impl.r, t, "M10", r0); ok {
		return
	}
	panic("no mock code matched")
}

func (impl *GenericServiceMockImpl[T, R]) MockM10() *gsmock.Mocker10[T] {
	t := reflect.TypeFor[GenericServiceMockImpl[T, R]]()
	return gsmock.NewMocker10[T](impl.r, t, "M10")
}

func (impl *GenericServiceMockImpl[T, R]) M11(r0 T) R {
	t := reflect.TypeFor[GenericServiceMockImpl[T, R]]()
	if ret, ok := gsmock.Invoke(impl.r, t, "M11", r0); ok {
		return gsmock.Unbox1[R](ret)
	}
	panic("no mock code matched")
}

func (impl *GenericServiceMockImpl[T, R]) MockM11() *gsmock.Mocker11[T, R] {
	t := reflect.TypeFor[GenericServiceMockImpl[T, R]]()
	return gsmock.NewMocker11[T, R](impl.r, t, "M11")
}

func (impl *GenericServiceMockImpl[T, R]) M02() (R, bool) {
	t := reflect.TypeFor[GenericServiceMockImpl[T, R]]()
	if ret, ok := gsmock.Invoke(impl.r, t, "M02"); ok {
		return gsmock.Unbox2[R, bool](ret)
	}
	panic("no mock code matched")
}

func (impl *GenericServiceMockImpl[T, R]) MockM02() *gsmock.Mocker02[R, bool] {
	t := reflect.TypeFor[GenericServiceMockImpl[T, R]]()
	return gsmock.NewMocker02[R, bool](impl.r, t, "M02")
}

func (impl *GenericServiceMockImpl[T, R]) M12(r0 T) (R, bool) {
	t := reflect.TypeFor[GenericServiceMockImpl[T, R]]()
	if ret, ok := gsmock.Invoke(impl.r, t, "M12", r0); ok {
		return gsmock.Unbox2[R, bool](ret)
	}
	panic("no mock code matched")
}

func (impl *GenericServiceMockImpl[T, R]) MockM12() *gsmock.Mocker12[T, R, bool] {
	t := reflect.TypeFor[GenericServiceMockImpl[T, R]]()
	return gsmock.NewMocker12[T, R, bool](impl.r, t, "M12")
}

func (impl *GenericServiceMockImpl[T, R]) M22(ctx context.Context, req map[string]T) (*Response, bool) {
	t := reflect.TypeFor[GenericServiceMockImpl[T, R]]()
	if ret, ok := gsmock.Invoke(impl.r, t, "M22", ctx, req); ok {
		return gsmock.Unbox2[*Response, bool](ret)
	}
	panic("no mock code matched")
}

func (impl *GenericServiceMockImpl[T, R]) MockM22() *gsmock.Mocker22[context.Context, map[string]T, *Response, bool] {
	t := reflect.TypeFor[GenericServiceMockImpl[T, R]]()
	return gsmock.NewMocker22[context.Context, map[string]T, *Response, bool](impl.r, t, "M22")
}

func (impl *GenericServiceMockImpl[T, R]) Printf(format string, args ...any) {
	t := reflect.TypeFor[GenericServiceMockImpl[T, R]]()
	if _, ok := gsmock.Invoke(impl.r, t, "Printf", format, args); ok {
		return
	}
	panic("no mock code matched")
}

func (impl *GenericServiceMockImpl[T, R]) MockPrintf() *gsmock.Mocker20[string, []any] {
	t := reflect.TypeFor[GenericServiceMockImpl[T, R]]()
	return gsmock.NewMocker20[string, []any](impl.r, t, "Printf")
}

type ServiceMockImpl struct {
	io.Writer

	r *gsmock.Manager
}

func NewServiceMockImpl(r *gsmock.Manager) *ServiceMockImpl {
	return &ServiceMockImpl{r: r}
}

func (impl *ServiceMockImpl) M00() {
	t := reflect.TypeFor[ServiceMockImpl]()
	if _, ok := gsmock.Invoke(impl.r, t, "M00"); ok {
		return
	}
	panic("no mock code matched")
}

func (impl *ServiceMockImpl) MockM00() *gsmock.Mocker00 {
	t := reflect.TypeFor[ServiceMockImpl]()
	return gsmock.NewMocker00(impl.r, t, "M00")
}

func (impl *ServiceMockImpl) M01() *Response {
	t := reflect.TypeFor[ServiceMockImpl]()
	if ret, ok := gsmock.Invoke(impl.r, t, "M01"); ok {
		return gsmock.Unbox1[*Response](ret)
	}
	panic("no mock code matched")
}

func (impl *ServiceMockImpl) MockM01() *gsmock.Mocker01[*Response] {
	t := reflect.TypeFor[ServiceMockImpl]()
	return gsmock.NewMocker01[*Response](impl.r, t, "M01")
}

func (impl *ServiceMockImpl) M10(r0 *exp.Request) {
	t := reflect.TypeFor[ServiceMockImpl]()
	if _, ok := gsmock.Invoke(impl.r, t, "M10", r0); ok {
		return
	}
	panic("no mock code matched")
}

func (impl *ServiceMockImpl) MockM10() *gsmock.Mocker10[*exp.Request] {
	t := reflect.TypeFor[ServiceMockImpl]()
	return gsmock.NewMocker10[*exp.Request](impl.r, t, "M10")
}

func (impl *ServiceMockImpl) M11(r0 *exp.Request) *Response {
	t := reflect.TypeFor[ServiceMockImpl]()
	if ret, ok := gsmock.Invoke(impl.r, t, "M11", r0); ok {
		return gsmock.Unbox1[*Response](ret)
	}
	panic("no mock code matched")
}

func (impl *ServiceMockImpl) MockM11() *gsmock.Mocker11[*exp.Request, *Response] {
	t := reflect.TypeFor[ServiceMockImpl]()
	return gsmock.NewMocker11[*exp.Request, *Response](impl.r, t, "M11")
}

func (impl *ServiceMockImpl) M02() (*Response, bool) {
	t := reflect.TypeFor[ServiceMockImpl]()
	if ret, ok := gsmock.Invoke(impl.r, t, "M02"); ok {
		return gsmock.Unbox2[*Response, bool](ret)
	}
	panic("no mock code matched")
}

func (impl *ServiceMockImpl) MockM02() *gsmock.Mocker02[*Response, bool] {
	t := reflect.TypeFor[ServiceMockImpl]()
	return gsmock.NewMocker02[*Response, bool](impl.r, t, "M02")
}

func (impl *ServiceMockImpl) M12(r0 *exp.Request) (*Response, bool) {
	t := reflect.TypeFor[ServiceMockImpl]()
	if ret, ok := gsmock.Invoke(impl.r, t, "M12", r0); ok {
		return gsmock.Unbox2[*Response, bool](ret)
	}
	panic("no mock code matched")
}

func (impl *ServiceMockImpl) MockM12() *gsmock.Mocker12[*exp.Request, *Response, bool] {
	t := reflect.TypeFor[ServiceMockImpl]()
	return gsmock.NewMocker12[*exp.Request, *Response, bool](impl.r, t, "M12")
}

func (impl *ServiceMockImpl) M22(ctx context.Context, req map[string]*exp.Request) (*Response, bool) {
	t := reflect.TypeFor[ServiceMockImpl]()
	if ret, ok := gsmock.Invoke(impl.r, t, "M22", ctx, req); ok {
		return gsmock.Unbox2[*Response, bool](ret)
	}
	panic("no mock code matched")
}

func (impl *ServiceMockImpl) MockM22() *gsmock.Mocker22[context.Context, map[string]*exp.Request, *Response, bool] {
	t := reflect.TypeFor[ServiceMockImpl]()
	return gsmock.NewMocker22[context.Context, map[string]*exp.Request, *Response, bool](impl.r, t, "M22")
}

func (impl *ServiceMockImpl) Printf(format string, args ...any) {
	t := reflect.TypeFor[ServiceMockImpl]()
	if _, ok := gsmock.Invoke(impl.r, t, "Printf", format, args); ok {
		return
	}
	panic("no mock code matched")
}

func (impl *ServiceMockImpl) MockPrintf() *gsmock.Mocker20[string, []any] {
	t := reflect.TypeFor[ServiceMockImpl]()
	return gsmock.NewMocker20[string, []any](impl.r, t, "Printf")
}
