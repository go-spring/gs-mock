/*
 * Copyright 2025 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/printer"
	"go/token"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/go-spring/mock"
)

var flagVar struct {
	outputFile     string
	mockInterfaces string
}

func init() {
	flag.StringVar(&flagVar.outputFile, "o", "", "output file")
	flag.StringVar(&flagVar.outputFile, "output", "", "output file")
	flag.StringVar(&flagVar.mockInterfaces, "t", "", "mock interfaces")
	flag.StringVar(&flagVar.mockInterfaces, "interfaces", "", "mock interfaces")
}

func main() {
	flag.Parse()
	run(runParam{
		sourceDir:      ".",
		outputFile:     flagVar.outputFile,
		mockInterfaces: flagVar.mockInterfaces,
	})
}

type runParam struct {
	sourceDir      string
	outputFile     string
	mockInterfaces string
}

func run(param runParam) {
	ctx := scanContext{
		outputFile:        param.outputFile,
		includeInterfaces: make(map[string]struct{}),
		excludeInterfaces: make(map[string]struct{}),
	}

	// pkgPath => pkgName
	pkgs := make(map[string]string)
	ctx.parse(param.mockInterfaces)
	interfaces := scanDir(param.sourceDir, ctx, pkgs)

	var s bytes.Buffer
	for _, mi := range interfaces {
		mockInterface(&s, mi, pkgs)
	}

	imports := make(map[string]string)
	imports["reflect"] = "reflect"
	imports["mock"] = "github.com/go-spring/mock"
	for _, m := range interfaces {
		for pkgName, pkgPath := range m.Imports {
			if _, ok := pkgs[pkgPath]; !ok {
				continue
			}
			path, ok := imports[pkgName]
			if ok && pkgPath != path {
				panic(fmt.Sprintf("conflict import path %s %s", pkgPath, path))
			}
			imports[pkgName] = pkgPath
		}
	}

	var h bytes.Buffer
	h.WriteString("// Code generated by mockgen. DO NOT EDIT.\n\n")
	h.WriteString("package testdata\n")
	h.WriteString("\n\nimport (\n")
	for pkgName, pkgPath := range imports {
		ss := strings.Split(pkgPath, "/")
		if pkgName == ss[len(ss)-1] {
			h.WriteString(fmt.Sprintf("\t\"%s\"\n", pkgPath))
		} else {
			h.WriteString(fmt.Sprintf("\t%s \"%s\"\n", pkgName, pkgPath))
		}
	}
	h.WriteString(")\n")
	h.Write(s.Bytes())

	b, err := format.Source(h.Bytes())
	if err != nil {
		panic(err)
	}

	if param.outputFile == "" {
		if _, err = os.Stdout.Write(b); err != nil {
			panic(err)
		}
		return
	}

	outputFile := filepath.Join(param.sourceDir, param.outputFile)
	err = os.WriteFile(outputFile, b, os.ModePerm)
	if err != nil {
		panic(err)
	}
}

type scanContext struct {
	outputFile        string
	includeInterfaces map[string]struct{}
	excludeInterfaces map[string]struct{}
}

func (ctx *scanContext) parse(mockInterfaces string) {
	if c := mockInterfaces[0]; c == '\'' || c == '"' {
		mockInterfaces = mockInterfaces[1 : len(mockInterfaces)-1]
	}
	ss := strings.Split(mockInterfaces, ",")
	for _, s := range ss {
		if len(s) == 0 {
			continue
		}
		if s[0] == '!' {
			ctx.excludeInterfaces[s[1:]] = struct{}{}
		} else {
			ctx.includeInterfaces[s] = struct{}{}
		}
	}
}

func (ctx *scanContext) mock(name string) bool {
	if len(ctx.includeInterfaces) > 0 {
		_, ok := ctx.includeInterfaces[name]
		return ok
	}
	_, ok := ctx.excludeInterfaces[name]
	return !ok
}

type MockInterface struct {
	Name       string
	Type       *ast.InterfaceType
	TypeParams [][]string
	File       string
	Imports    map[string]string
}

func scanDir(dir string, ctx scanContext, pkgs map[string]string) []MockInterface {
	entries, err := os.ReadDir(dir)
	if err != nil {
		panic(err)
	}
	var ret []MockInterface
	for _, entry := range entries {
		if entry.IsDir() {
			continue
		}
		if entry.Name() == ctx.outputFile {
			continue
		}
		if strings.HasSuffix(entry.Name(), "_test.go") {
			continue
		}
		arr := scanFile(ctx, filepath.Join(dir, entry.Name()), pkgs)
		ret = append(ret, arr...)
	}
	return ret
}

func scanFile(ctx scanContext, file string, pkgs map[string]string) []MockInterface {
	mode := parser.AllErrors
	node, err := parser.ParseFile(token.NewFileSet(), file, nil, mode)
	if err != nil {
		panic(err)
	}

	imports := make(map[string]string)
	for _, spec := range node.Imports {
		pkgPath := spec.Path.Value
		pkgPath = pkgPath[1 : len(pkgPath)-1]
		var pkgName string
		if spec.Name != nil {
			pkgName = spec.Name.Name
		} else {
			ss := strings.Split(pkgPath, "/")
			pkgName = ss[len(ss)-1]
		}
		imports[pkgName] = pkgPath
	}

	var ret []MockInterface
	for _, decl := range node.Decls {
		d, ok := decl.(*ast.GenDecl)
		if !ok || d.Tok != token.TYPE {
			continue
		}
		for _, spec := range d.Specs {
			s := spec.(*ast.TypeSpec)
			t, ok := s.Type.(*ast.InterfaceType)
			if !ok || len(t.Methods.List) == 0 {
				continue
			}
			name := s.Name.String()
			if !ctx.mock(name) {
				continue
			}
			var typeParams [][]string
			if s.TypeParams != nil {
				for _, f := range s.TypeParams.List {
					fName := f.Names[0].Name
					typeText, pkgName := getTypeText(f.Type)
					if pkgName != "" {
						pkgs[imports[pkgName]] = pkgName
					}
					typeParams = append(typeParams, []string{fName, typeText})
				}
			}
			ret = append(ret, MockInterface{
				Name:       name,
				Type:       t,
				TypeParams: typeParams,
				File:       file,
				Imports:    imports,
			})
		}
	}
	return ret
}

func mockInterface(s *bytes.Buffer, mi MockInterface, pkgs map[string]string) {

	var (
		typeParams string
		typeTokens string
	)
	for i, param := range mi.TypeParams {
		if i > 0 {
			typeParams += ", "
			typeTokens += ", "
		}
		typeParams += param[0] + " " + param[1]
		typeTokens += param[0]
	}

	var embedInterfaces string
	for _, method := range mi.Type.Methods.List {
		if len(method.Names) == 0 {
			embedInterfaces += "\t"
			typeText, pkgName := getTypeText(method.Type)
			if pkgName != "" {
				pkgs[mi.Imports[pkgName]] = pkgName
			}
			embedInterfaces += typeText
			embedInterfaces += "\n"
		}
	}

	if len(mi.TypeParams) > 0 {
		s.WriteString(fmt.Sprintf("\ntype %sMockImpl[%s] struct {\n\t%sr *mock.Manager\n}\n", mi.Name, typeParams, embedInterfaces))
		s.WriteString(fmt.Sprintf("\nfunc New%sMockImpl[%s](r *mock.Manager) *%sMockImpl[%s] {", mi.Name, typeParams, mi.Name, typeTokens))
		s.WriteString(fmt.Sprintf("\n\treturn &%sMockImpl[%s]{r:r}", mi.Name, typeTokens))
		s.WriteString("\n}\n")
	} else {
		s.WriteString(fmt.Sprintf("\ntype %sMockImpl struct {\n\t%sr *mock.Manager\n}\n", mi.Name, embedInterfaces))
		s.WriteString(fmt.Sprintf("\nfunc New%sMockImpl(r *mock.Manager) *%sMockImpl {", mi.Name, mi.Name))
		s.WriteString(fmt.Sprintf("\n\treturn &%sMockImpl{r:r}", mi.Name))
		s.WriteString("\n}\n")
	}

	for j, method := range mi.Type.Methods.List {
		if len(method.Names) == 0 {
			continue
		}
		if j > 0 {
			s.WriteString("\n")
		}
		methodName := method.Names[0].Name
		ft := method.Type.(*ast.FuncType)
		paramCount := len(ft.Params.List)
		if paramCount > mock.MaxParamCount {
			panic(fmt.Sprintf("have more than %d parameters", mock.MaxParamCount))
		}
		resultCount := len(ft.Results.List)
		if resultCount > mock.MaxResultCount {
			panic(fmt.Sprintf("have more than %d results", mock.MaxResultCount))
		}
		{
			if len(mi.TypeParams) > 0 {
				s.WriteString(fmt.Sprintf("\nfunc (impl *%sMockImpl[%s]) %s(", mi.Name, typeTokens, methodName))
			} else {
				s.WriteString(fmt.Sprintf("\nfunc (impl *%sMockImpl) %s(", mi.Name, methodName))
			}
			for i, param := range ft.Params.List {
				s.WriteString(param.Names[0].Name)
				s.WriteString(" ")
				typeText, pkgName := getTypeText(param.Type)
				if pkgName != "" {
					pkgs[mi.Imports[pkgName]] = pkgName
				}
				s.WriteString(typeText)
				if i < len(ft.Params.List)-1 {
					s.WriteString(", ")
				}
			}
			s.WriteString(") (")
			for i, result := range ft.Results.List {
				typeText, pkgName := getTypeText(result.Type)
				if pkgName != "" {
					pkgs[mi.Imports[pkgName]] = pkgName
				}
				s.WriteString(typeText)
				if i < len(ft.Results.List)-1 {
					s.WriteString(", ")
				}
			}
			s.WriteString(") {")
			if len(mi.TypeParams) > 0 {
				s.WriteString(fmt.Sprintf("\n\tt := reflect.TypeFor[%sMockImpl[%s]]()", mi.Name, typeTokens))
			} else {
				s.WriteString(fmt.Sprintf("\n\tt := reflect.TypeFor[%sMockImpl]()", mi.Name))
			}
			s.WriteString(fmt.Sprintf("\n\tif ret, ok := mock.Invoke(impl.r, t, \"%s\", ", methodName))
			for i, param := range ft.Params.List {
				s.WriteString(param.Names[0].Name)
				if i < len(ft.Params.List)-1 {
					s.WriteString(", ")
				}
			}
			s.WriteString("); ok {")
			s.WriteString(fmt.Sprintf("\n\t\treturn mock.Unbox%d[", resultCount))
			for i, result := range ft.Results.List {
				typeText, pkgName := getTypeText(result.Type)
				if pkgName != "" {
					pkgs[mi.Imports[pkgName]] = pkgName
				}
				s.WriteString(typeText)
				if i < len(ft.Results.List)-1 {
					s.WriteString(", ")
				}
			}
			s.WriteString("](ret)")
			s.WriteString("\n\t}")
			s.WriteString("\n\tpanic(\"no mock code matched\")")
			s.WriteString("\n}")
		}
		s.WriteString("\n")
		{
			if len(mi.TypeParams) > 0 {
				s.WriteString(fmt.Sprintf("\nfunc (impl *%sMockImpl[%s]) Mock%s(", mi.Name, typeTokens, methodName))
			} else {
				s.WriteString(fmt.Sprintf("\nfunc (impl *%sMockImpl) Mock%s(", mi.Name, methodName))
			}
			s.WriteString(fmt.Sprintf(") *mock.Mocker%d%d[", paramCount, resultCount))
			for i, param := range ft.Params.List {
				typeText, pkgName := getTypeText(param.Type)
				if pkgName != "" {
					pkgs[mi.Imports[pkgName]] = pkgName
				}
				s.WriteString(typeText)
				if i < len(ft.Params.List)-1 {
					s.WriteString(", ")
				}
			}
			s.WriteString(", ")
			for i, result := range ft.Results.List {
				typeText, pkgName := getTypeText(result.Type)
				if pkgName != "" {
					pkgs[mi.Imports[pkgName]] = pkgName
				}
				s.WriteString(typeText)
				if i < len(ft.Results.List)-1 {
					s.WriteString(", ")
				}
			}
			s.WriteString("] {")
			if len(mi.TypeParams) > 0 {
				s.WriteString(fmt.Sprintf("\n\tt := reflect.TypeFor[%sMockImpl[%s]]()", mi.Name, typeTokens))
			} else {
				s.WriteString(fmt.Sprintf("\n\tt := reflect.TypeFor[%sMockImpl]()", mi.Name))
			}
			s.WriteString(fmt.Sprintf("\n\treturn mock.NewMocker%d%d[", paramCount, resultCount))
			for i, param := range ft.Params.List {
				typeText, pkgName := getTypeText(param.Type)
				if pkgName != "" {
					pkgs[mi.Imports[pkgName]] = pkgName
				}
				s.WriteString(typeText)
				if i < len(ft.Params.List)-1 {
					s.WriteString(", ")
				}
			}
			s.WriteString(", ")
			for i, result := range ft.Results.List {
				typeText, pkgName := getTypeText(result.Type)
				if pkgName != "" {
					pkgs[mi.Imports[pkgName]] = pkgName
				}
				s.WriteString(typeText)
				if i < len(ft.Results.List)-1 {
					s.WriteString(", ")
				}
			}
			s.WriteString(fmt.Sprintf("](impl.r, t, \"%s\")", methodName))
			s.WriteString("\n}")
		}
	}
}

var (
	typeTextBuffer  bytes.Buffer
	typeTextFileSet = token.NewFileSet()
	pkgNameSelector = regexp.MustCompile(`([a-zA-Z0-9_]+\.)`)
)

// getTypeText returns the text representation of the given type.
func getTypeText(t ast.Expr) (typeText string, pkgName string) {
	typeTextBuffer.Reset()
	_ = printer.Fprint(&typeTextBuffer, typeTextFileSet, t)
	typeText = typeTextBuffer.String()
	pkgName = pkgNameSelector.FindString(typeText)
	if pkgName != "" {
		pkgName = pkgName[:len(pkgName)-1]
	}
	return
}
