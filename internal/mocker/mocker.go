/*
 * Copyright 2025 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package main

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"runtime"
	"strings"
	"text/template"
)

// init sets the working directory of the program to the directory
// where this source file resides. This ensures that relative paths
// used later in the program (e.g., for output) are resolved correctly.
func init() {
	var execDir string
	_, filename, _, ok := runtime.Caller(0)
	if ok {
		execDir = filepath.Dir(filename)
	}
	err := os.Chdir(execDir)
	if err != nil {
		panic(err)
	}
	workDir, err := os.Getwd()
	if err != nil {
		panic(err)
	}
	fmt.Println(workDir)
}

func main() {
	s := bytes.NewBuffer(nil)

	// Write the file header.
	s.WriteString(`
	// Code generated by internal/mocker. DO NOT EDIT.

	package gsmock
	
	import (
		"reflect"
	)`)

	const (
		MaxParamCount  = 5
		MaxResultCount = 5
	)

	// Write these constants into the generated file.
	s.WriteString(fmt.Sprintf(`
	const (
		MaxParamCount  = %d
		MaxResultCount = %d
	)`, MaxParamCount, MaxResultCount))

	for i := 0; i <= MaxParamCount; i++ {
		for j := 0; j <= MaxResultCount; j++ {
			mockerName := fmt.Sprintf("Mocker%d%d", i, j)
			invokerName := fmt.Sprintf("Invoker%d%d", i, j)

			// Build type parameter lists for request arguments.
			req := make([]string, i)
			for k := 0; k < i; k++ {
				req[k] = "T" + fmt.Sprint(k+1)
			}

			// Build type parameter lists and identifiers for return values.
			resp := make([]string, j)
			respOnlyArg := make([]string, j)
			respWithArg := make([]string, j)
			for k := 0; k < j; k++ {
				resp[k] = "R" + fmt.Sprint(k+1)
				respOnlyArg[k] = "r" + fmt.Sprint(k+1)
				respWithArg[k] = respOnlyArg[k] + " " + resp[k]
			}

			// Build type assertions for converting []any to typed arguments.
			cvtParams := make([]string, i)
			for k := 0; k < i; k++ {
				cvtParams[k] = "params[" + fmt.Sprint(k) + "].(T" + fmt.Sprint(k+1) + ")"
			}

			// Prepare template data.
			data := map[string]any{
				"mockerName":  mockerName,
				"invokerName": invokerName,
				"req":         strings.Join(req, ", "),
				"resp":        strings.Join(resp, ", "),
				"respOnlyArg": strings.Join(respOnlyArg, ", "),
				"respWithArg": strings.Join(respWithArg, ", "),
				"cvtParams":   strings.Join(cvtParams, ", "),
			}

			// Execute the appropriate template for this (i, j).
			if err := getTemplate(i, j).Execute(s, data); err != nil {
				panic(fmt.Errorf("error executing template(%s): %w", mockerName, err))
			}
		}
	}

	// Format the generated code using go/format.
	b, err := format.Source(s.Bytes())
	if err != nil {
		panic(fmt.Errorf("error formatting source code: %w", err))
	}

	// Write the formatted code to the output file.
	const fileName = "../../gsmock/mocker.go"
	err = os.WriteFile(fileName, b, os.ModePerm)
	if err != nil {
		panic(fmt.Errorf("error writing file(%s): %w", fileName, err))
	}
}

// getTemplate selects the appropriate template based on
// the number of request parameters (i) and return values (j).
func getTemplate(i, j int) *template.Template {
	if i == 0 {
		if j == 0 {
			return mocker00Tmpl
		} else {
			return mocker0NTmpl
		}
	} else {
		if j == 0 {
			return mockerN0Tmpl
		} else {
			return mockerNNTmpl
		}
	}
}
