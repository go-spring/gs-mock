/*
 * Copyright 2025 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package main

import (
	"text/template"
)

// tmplFileHeader defines the header template for the generated Go file.
var tmplFileHeader = template.Must(template.New("FileHeader").Parse(`
// Code generated by gs-mock {{.ToolVersion}}. DO NOT EDIT.
// Source: https://github.com/go-spring/gs-mock
// gs mock {{.ToolCommand}}

package {{.Package}}

import (
{{.Imports}}
)`))

// tmplInterface defines the template for generating a mock implementation
// of an interface. It supports both generic (type-parameterized) and
// non-generic interfaces. Each generated mock embeds the original interface(s)
// and includes a reference to the mock manager.
var tmplInterface = template.Must(template.New("Interface").Parse(`
{{- if gt (len .TypeParams) 0 }}
// {{.Name}}MockImpl is a generated mock implementation of the {{.Name}} interface
// with type parameters [{{.TypeParams}}].
type {{.Name}}MockImpl[{{.TypeParams}}] struct {
	{{.EmbedInterfaces}}
	r *gsmock.Manager
}

// New{{.Name}}MockImpl creates a new mock instance for {{.Name}} with the given
// gsmock.Manager and initializes the embedded interfaces.
func New{{.Name}}MockImpl[{{.TypeParams}}](r *gsmock.Manager) *{{.Name}}MockImpl[{{.TypeParamNames}}] {
	return &{{.Name}}MockImpl[{{.TypeParamNames}}]{r: r}
}
{{- else}}
// {{.Name}}MockImpl is a generated mock implementation of the {{.Name}} interface.
// It embeds the original interfaces and provides methods to register mock behaviors.
type {{.Name}}MockImpl struct {
	{{.EmbedInterfaces}}
	r *gsmock.Manager
}

// New{{.Name}}MockImpl creates a new mock instance for {{.Name}} with the given
// gsmock.Manager and initializes the embedded interfaces.
func New{{.Name}}MockImpl(r *gsmock.Manager) *{{.Name}}MockImpl {
	return &{{.Name}}MockImpl{r: r}
}
{{- end}}
`))

// getTmplMethod selects the appropriate method template based on
// the number of parameters and return values of a method.
func getTmplMethod(paramCount int, resultCount int) *template.Template {
	if paramCount == 0 {
		if resultCount == 0 {
			return tmplMethod00
		} else {
			return tmplMethod0N
		}
	} else {
		if resultCount == 0 {
			return tmplMethodN0
		} else {
			return tmplMethodNN
		}
	}
}

// tmplMethod00 defines a template for methods with no parameters and no return values.
// It generates the method implementation and a corresponding MockXXX() method
// for registering mocks.
var tmplMethod00 = template.Must(template.New("Method00").Parse(`
{{if gt (len .i.TypeParams) 0 }}
// {{.m.Name}} executes the mocked {{.m.Name}} method.
// Panics if no mock is registered.
func (impl *{{.i.Name}}MockImpl[{{.i.TypeParamNames}}]) {{.m.Name}}(){
	t := reflect.TypeFor[{{.i.Name}}MockImpl[{{.i.TypeParamNames}}]]()
	if _, ok := gsmock.Invoke(impl.r, t, "{{.m.Name}}"); ok {
		return
	}
	panic("no mock code matched for {{.i.Name}}.{{.m.Name}}")
}

// Mock{{.m.Name}} returns a Mocker00 instance to register mock behavior for {{.m.Name}}.
func (impl *{{.i.Name}}MockImpl[{{.i.TypeParamNames}}]) Mock{{.m.Name}}() *gsmock.Mocker00 {
	t := reflect.TypeFor[{{.i.Name}}MockImpl[{{.i.TypeParamNames}}]]()
	return gsmock.NewMocker00(impl.r, t, "{{.m.Name}}")
}
{{- else}}
// {{.m.Name}} executes the mocked {{.m.Name}} method.
// Panics if no mock is registered.
func (impl *{{.i.Name}}MockImpl) {{.m.Name}}(){
	t := reflect.TypeFor[{{.i.Name}}MockImpl]()
	if _, ok := gsmock.Invoke(impl.r, t, "{{.m.Name}}"); ok {
		return
	}
	panic("no mock code matched for {{.i.Name}}.{{.m.Name}}")
}

// Mock{{.m.Name}} returns a Mocker00 instance to register mock behavior for {{.m.Name}}.
func (impl *{{.i.Name}}MockImpl) Mock{{.m.Name}}() *gsmock.Mocker00 {
	t := reflect.TypeFor[{{.i.Name}}MockImpl]()
	return gsmock.NewMocker00(impl.r, t, "{{.m.Name}}")
}
{{- end}}
`))

// tmplMethod0N defines a template for methods with no parameters but N return values.
// It generates the method implementation and a corresponding MockXXX() registration method.
var tmplMethod0N = template.Must(template.New("Method0N").Parse(`
{{if gt (len .i.TypeParams) 0 }}
// {{.m.Name}} executes the mocked {{.m.Name}} method.
func (impl *{{.i.Name}}MockImpl[{{.i.TypeParamNames}}]) {{.m.Name}}()({{.m.ResultTypes}}){
	t := reflect.TypeFor[{{.i.Name}}MockImpl[{{.i.TypeParamNames}}]]()
	if ret, ok := gsmock.Invoke(impl.r, t, "{{.m.Name}}"); ok {
		return gsmock.Unbox{{.m.ResultCount}}[{{.m.ResultTypes}}](ret)
	}
	panic("no mock code matched for {{.i.Name}}.{{.m.Name}}")
}

// Mock{{.m.Name}} returns a Mocker0N instance to register mock behavior for {{.m.Name}}.
func (impl *{{.i.Name}}MockImpl[{{.i.TypeParamNames}}]) Mock{{.m.Name}}() *gsmock.Mocker0{{.m.ResultCount}}[{{.m.ResultTypes}}] {
	t := reflect.TypeFor[{{.i.Name}}MockImpl[{{.i.TypeParamNames}}]]()
	return gsmock.NewMocker0{{.m.ResultCount}}[{{.m.ResultTypes}}](impl.r, t, "{{.m.Name}}")
}
{{- else}}
// {{.m.Name}} executes the mocked {{.m.Name}} method.
func (impl *{{.i.Name}}MockImpl) {{.m.Name}}()({{.m.ResultTypes}}){
	t := reflect.TypeFor[{{.i.Name}}MockImpl]()
	if ret, ok := gsmock.Invoke(impl.r, t, "{{.m.Name}}"); ok {
		return gsmock.Unbox{{.m.ResultCount}}[{{.m.ResultTypes}}](ret)
	}
	panic("no mock code matched for {{.i.Name}}.{{.m.Name}}")
}

// Mock{{.m.Name}} returns a Mocker0N instance to register mock behavior for {{.m.Name}}.
func (impl *{{.i.Name}}MockImpl) Mock{{.m.Name}}() *gsmock.Mocker0{{.m.ResultCount}}[{{.m.ResultTypes}}] {
	t := reflect.TypeFor[{{.i.Name}}MockImpl]()
	return gsmock.NewMocker0{{.m.ResultCount}}[{{.m.ResultTypes}}](impl.r, t, "{{.m.Name}}")
}
{{- end}}
`))

// tmplMethodN0 defines a template for methods with N parameters and no return values.
// It generates the method implementation and a corresponding MockXXX() registration method.
var tmplMethodN0 = template.Must(template.New("MethodN0").Parse(`
{{if gt (len .i.TypeParams) 0 }}
// {{.m.Name}} executes the mocked {{.m.Name}} method.
func (impl *{{.i.Name}}MockImpl[{{.i.TypeParamNames}}]) {{.m.Name}}({{.m.Params}}){
	t := reflect.TypeFor[{{.i.Name}}MockImpl[{{.i.TypeParamNames}}]]()
	if _, ok := gsmock.Invoke(impl.r, t, "{{.m.Name}}", {{.m.ParamNames}}); ok {
		return
	}
	panic("no mock code matched for {{.i.Name}}.{{.m.Name}}")
}

// Mock{{.m.Name}} returns a MockerN0 instance to register mock behavior for {{.m.Name}}.
func (impl *{{.i.Name}}MockImpl[{{.i.TypeParamNames}}]) Mock{{.m.Name}}() *gsmock.Mocker{{.m.ParamCount}}0[{{.m.ParamTypes}}] {
	t := reflect.TypeFor[{{.i.Name}}MockImpl[{{.i.TypeParamNames}}]]()
	return gsmock.NewMocker{{.m.ParamCount}}0[{{.m.ParamTypes}}](impl.r, t, "{{.m.Name}}")
}
{{- else}}
// {{.m.Name}} executes the mocked {{.m.Name}} method.
func (impl *{{.i.Name}}MockImpl) {{.m.Name}}({{.m.Params}}){
	t := reflect.TypeFor[{{.i.Name}}MockImpl]()
	if _, ok := gsmock.Invoke(impl.r, t, "{{.m.Name}}", {{.m.ParamNames}}); ok {
		return
	}
	panic("no mock code matched for {{.i.Name}}.{{.m.Name}}")
}

// Mock{{.m.Name}} returns a MockerN0 instance to register mock behavior for {{.m.Name}}.
func (impl *{{.i.Name}}MockImpl) Mock{{.m.Name}}() *gsmock.Mocker{{.m.ParamCount}}0[{{.m.ParamTypes}}] {
	t := reflect.TypeFor[{{.i.Name}}MockImpl]()
	return gsmock.NewMocker{{.m.ParamCount}}0[{{.m.ParamTypes}}](impl.r, t, "{{.m.Name}}")
}
{{- end}}
`))

// tmplMethodNN defines a template for methods with N parameters and N return values.
// It generates the method implementation and a corresponding MockXXX() registration method.
var tmplMethodNN = template.Must(template.New("MethodNN").Parse(`
{{if gt (len .i.TypeParams) 0 }}
// {{.m.Name}} executes the mocked {{.m.Name}} method.
func (impl *{{.i.Name}}MockImpl[{{.i.TypeParamNames}}]) {{.m.Name}}({{.m.Params}})({{.m.ResultTypes}}){
	t := reflect.TypeFor[{{.i.Name}}MockImpl[{{.i.TypeParamNames}}]]()
	if ret, ok := gsmock.Invoke(impl.r, t, "{{.m.Name}}", {{.m.ParamNames}}); ok {
		return gsmock.Unbox{{.m.ResultCount}}[{{.m.ResultTypes}}](ret)
	}
	panic("no mock code matched for {{.i.Name}}.{{.m.Name}}")
}

// Mock{{.m.Name}} returns a MockerNN instance to register mock behavior for {{.m.Name}}.
func (impl *{{.i.Name}}MockImpl[{{.i.TypeParamNames}}]) Mock{{.m.Name}}() *gsmock.Mocker{{.m.ParamCount}}{{.m.ResultCount}}[{{.m.ParamTypes}}, {{.m.ResultTypes}}] {
	t := reflect.TypeFor[{{.i.Name}}MockImpl[{{.i.TypeParamNames}}]]()
	return gsmock.NewMocker{{.m.ParamCount}}{{.m.ResultCount}}[{{.m.ParamTypes}}, {{.m.ResultTypes}}](impl.r, t, "{{.m.Name}}")
}
{{- else}}
// {{.m.Name}} executes the mocked {{.m.Name}} method.
// with {{.m.ParamCount}} parameters and {{.m.ResultCount}} return values.
func (impl *{{.i.Name}}MockImpl) {{.m.Name}}({{.m.Params}})({{.m.ResultTypes}}){
	t := reflect.TypeFor[{{.i.Name}}MockImpl]()
	if ret, ok := gsmock.Invoke(impl.r, t, "{{.m.Name}}", {{.m.ParamNames}}); ok {
		return gsmock.Unbox{{.m.ResultCount}}[{{.m.ResultTypes}}](ret)
	}
	panic("no mock code matched for {{.i.Name}}.{{.m.Name}}")
}

// Mock{{.m.Name}} returns a MockerNN instance to register mock behavior for {{.m.Name}}.
func (impl *{{.i.Name}}MockImpl) Mock{{.m.Name}}() *gsmock.Mocker{{.m.ParamCount}}{{.m.ResultCount}}[{{.m.ParamTypes}}, {{.m.ResultTypes}}] {
	t := reflect.TypeFor[{{.i.Name}}MockImpl]()
	return gsmock.NewMocker{{.m.ParamCount}}{{.m.ResultCount}}[{{.m.ParamTypes}}, {{.m.ResultTypes}}](impl.r, t, "{{.m.Name}}")
}
{{- end}}
`))
