/*
 * Copyright 2025 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package main

import (
	"text/template"
)

// tmplFileHeader defines the header template for the generated Go file.
// It includes metadata such as tool version and command, the package name,
// and the required import statements.
var tmplFileHeader = template.Must(template.New("").Parse(`
// Code generated by gsmock {{.ToolVersion}}. DO NOT EDIT.
// Source: https://github.com/go-spring/gs-mock
// gs-mock {{.ToolCommand}}

package {{.Package}}

import (
{{.Imports}}
)`))

// tmplInterface defines the template for generating the mock implementation
// of an interface. It supports both generic (with type parameters) and
// non-generic interfaces, embedding the original interfaces and initializing
// the mock manager.
var tmplInterface = template.Must(template.New("").Parse(`
{{- if gt (len .TypeParams) 0 }}
type {{.Name}}MockImpl[{{.TypeParams}}] struct {
	{{.EmbedInterfaces}}
	r *gsmock.Manager
}

func New{{.Name}}MockImpl[{{.TypeParams}}](r *gsmock.Manager) *{{.Name}}MockImpl[{{.TypeParamNames}}] {
	return &{{.Name}}MockImpl[{{.TypeParamNames}}]{r: r}
}
{{- else}}
type {{.Name}}MockImpl struct {
	{{.EmbedInterfaces}}
	r *gsmock.Manager
}

func New{{.Name}}MockImpl(r *gsmock.Manager) *{{.Name}}MockImpl {
	return &{{.Name}}MockImpl{r: r}
}
{{- end}}
`))

// getTmplMethod selects and returns the appropriate method template based on
// the number of parameters and return values of a method.
func getTmplMethod(paramCount int, resultCount int) *template.Template {
	if paramCount == 0 {
		if resultCount == 0 {
			return tmplMethod00
		} else {
			return tmplMethod0N
		}
	} else {
		if resultCount == 0 {
			return tmplMethodN0
		} else {
			return tmplMethodNN
		}
	}
}

// tmplMethod00 defines the template for methods with no parameters and no return values.
// It includes the method implementation and a corresponding mock registration method.
// Supports both generic and non-generic versions.
var tmplMethod00 = template.Must(template.New("").Parse(`
{{if gt (len .i.TypeParams) 0 }}
func (impl *{{.i.Name}}MockImpl[{{.i.TypeParamNames}}]) {{.m.Name}}(){
	t := reflect.TypeFor[{{.i.Name}}MockImpl[{{.i.TypeParamNames}}]]()
	if _, ok := gsmock.Invoke(impl.r, t, "{{.m.Name}}"); ok {
		return
	}
	panic("no mock code matched")
}

func (impl *{{.i.Name}}MockImpl[{{.i.TypeParamNames}}]) Mock{{.m.Name}}() *gsmock.Mocker00 {
	t := reflect.TypeFor[{{.i.Name}}MockImpl[{{.i.TypeParamNames}}]]()
	return gsmock.NewMocker00(impl.r, t, "{{.m.Name}}")
}
{{- else}}
func (impl *{{.i.Name}}MockImpl) {{.m.Name}}(){
	t := reflect.TypeFor[{{.i.Name}}MockImpl]()
	if _, ok := gsmock.Invoke(impl.r, t, "{{.m.Name}}"); ok {
		return
	}
	panic("no mock code matched")
}

func (impl *{{.i.Name}}MockImpl) Mock{{.m.Name}}() *gsmock.Mocker00 {
	t := reflect.TypeFor[{{.i.Name}}MockImpl]()
	return gsmock.NewMocker00(impl.r, t, "{{.m.Name}}")
}
{{- end}}
`))

// tmplMethod0N defines the template for methods with no parameters but N return values.
// It includes the method implementation and a corresponding mock registration method.
// Supports both generic and non-generic versions.
var tmplMethod0N = template.Must(template.New("").Parse(`
{{if gt (len .i.TypeParams) 0 }}
func (impl *{{.i.Name}}MockImpl[{{.i.TypeParamNames}}]) {{.m.Name}}()({{.m.ResultTypes}}){
	t := reflect.TypeFor[{{.i.Name}}MockImpl[{{.i.TypeParamNames}}]]()
	if ret, ok := gsmock.Invoke(impl.r, t, "{{.m.Name}}"); ok {
		return gsmock.Unbox{{.m.ResultCount}}[{{.m.ResultTypes}}](ret)
	}
	panic("no mock code matched")
}

func (impl *{{.i.Name}}MockImpl[{{.i.TypeParamNames}}]) Mock{{.m.Name}}() *gsmock.Mocker0{{.m.ResultCount}}[{{.m.ResultTypes}}] {
	t := reflect.TypeFor[{{.i.Name}}MockImpl[{{.i.TypeParamNames}}]]()
	return gsmock.NewMocker0{{.m.ResultCount}}[{{.m.ResultTypes}}](impl.r, t, "{{.m.Name}}")
}
{{- else}}
func (impl *{{.i.Name}}MockImpl) {{.m.Name}}()({{.m.ResultTypes}}){
	t := reflect.TypeFor[{{.i.Name}}MockImpl]()
	if ret, ok := gsmock.Invoke(impl.r, t, "{{.m.Name}}"); ok {
		return gsmock.Unbox{{.m.ResultCount}}[{{.m.ResultTypes}}](ret)
	}
	panic("no mock code matched")
}

func (impl *{{.i.Name}}MockImpl) Mock{{.m.Name}}() *gsmock.Mocker0{{.m.ResultCount}}[{{.m.ResultTypes}}] {
	t := reflect.TypeFor[{{.i.Name}}MockImpl]()
	return gsmock.NewMocker0{{.m.ResultCount}}[{{.m.ResultTypes}}](impl.r, t, "{{.m.Name}}")
}
{{- end}}
`))

// tmplMethodN0 defines the template for methods with N parameters and no return values.
// It includes the method implementation and a corresponding mock registration method.
// Supports both generic and non-generic versions.
var tmplMethodN0 = template.Must(template.New("").Parse(`
{{if gt (len .i.TypeParams) 0 }}
func (impl *{{.i.Name}}MockImpl[{{.i.TypeParamNames}}]) {{.m.Name}}({{.m.Params}}){
	t := reflect.TypeFor[{{.i.Name}}MockImpl[{{.i.TypeParamNames}}]]()
	if _, ok := gsmock.Invoke(impl.r, t, "{{.m.Name}}", {{.m.ParamNames}}); ok {
		return
	}
	panic("no mock code matched")
}

func (impl *{{.i.Name}}MockImpl[{{.i.TypeParamNames}}]) Mock{{.m.Name}}() *gsmock.Mocker{{.m.ParamCount}}0[{{.m.ParamTypes}}] {
	t := reflect.TypeFor[{{.i.Name}}MockImpl[{{.i.TypeParamNames}}]]()
	return gsmock.NewMocker{{.m.ParamCount}}0[{{.m.ParamTypes}}](impl.r, t, "{{.m.Name}}")
}
{{- else}}
func (impl *{{.i.Name}}MockImpl) {{.m.Name}}({{.m.Params}}){
	t := reflect.TypeFor[{{.i.Name}}MockImpl]()
	if _, ok := gsmock.Invoke(impl.r, t, "{{.m.Name}}", {{.m.ParamNames}}); ok {
		return
	}
	panic("no mock code matched")
}

func (impl *{{.i.Name}}MockImpl) Mock{{.m.Name}}() *gsmock.Mocker{{.m.ParamCount}}0[{{.m.ParamTypes}}] {
	t := reflect.TypeFor[{{.i.Name}}MockImpl]()
	return gsmock.NewMocker{{.m.ParamCount}}0[{{.m.ParamTypes}}](impl.r, t, "{{.m.Name}}")
}
{{- end}}
`))

// tmplMethodNN defines the template for methods with N parameters and N return values.
// It includes the method implementation and a corresponding mock registration method.
// Supports both generic and non-generic versions.
var tmplMethodNN = template.Must(template.New("").Parse(`
{{if gt (len .i.TypeParams) 0 }}
func (impl *{{.i.Name}}MockImpl[{{.i.TypeParamNames}}]) {{.m.Name}}({{.m.Params}})({{.m.ResultTypes}}){
	t := reflect.TypeFor[{{.i.Name}}MockImpl[{{.i.TypeParamNames}}]]()
	if ret, ok := gsmock.Invoke(impl.r, t, "{{.m.Name}}", {{.m.ParamNames}}); ok {
		return gsmock.Unbox{{.m.ResultCount}}[{{.m.ResultTypes}}](ret)
	}
	panic("no mock code matched")
}

func (impl *{{.i.Name}}MockImpl[{{.i.TypeParamNames}}]) Mock{{.m.Name}}() *gsmock.Mocker{{.m.ParamCount}}{{.m.ResultCount}}[{{.m.ParamTypes}}, {{.m.ResultTypes}}] {
	t := reflect.TypeFor[{{.i.Name}}MockImpl[{{.i.TypeParamNames}}]]()
	return gsmock.NewMocker{{.m.ParamCount}}{{.m.ResultCount}}[{{.m.ParamTypes}}, {{.m.ResultTypes}}](impl.r, t, "{{.m.Name}}")
}
{{- else}}
func (impl *{{.i.Name}}MockImpl) {{.m.Name}}({{.m.Params}})({{.m.ResultTypes}}){
	t := reflect.TypeFor[{{.i.Name}}MockImpl]()
	if ret, ok := gsmock.Invoke(impl.r, t, "{{.m.Name}}", {{.m.ParamNames}}); ok {
		return gsmock.Unbox{{.m.ResultCount}}[{{.m.ResultTypes}}](ret)
	}
	panic("no mock code matched")
}

func (impl *{{.i.Name}}MockImpl) Mock{{.m.Name}}() *gsmock.Mocker{{.m.ParamCount}}{{.m.ResultCount}}[{{.m.ParamTypes}}, {{.m.ResultTypes}}] {
	t := reflect.TypeFor[{{.i.Name}}MockImpl]()
	return gsmock.NewMocker{{.m.ParamCount}}{{.m.ResultCount}}[{{.m.ParamTypes}}, {{.m.ResultTypes}}](impl.r, t, "{{.m.Name}}")
}
{{- end}}
`))
