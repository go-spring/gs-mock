/*
 * Copyright 2025 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/printer"
	"go/token"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"text/template"

	"github.com/go-spring/mock"
)

const ToolVersion = "v0.0.1"

var flagVar struct {
	outputFile     string
	mockInterfaces string
}

func init() {
	flag.StringVar(&flagVar.outputFile, "o", "", "output file")
	flag.StringVar(&flagVar.outputFile, "output", "", "output file")
	flag.StringVar(&flagVar.mockInterfaces, "i", "", "mock interfaces")
	flag.StringVar(&flagVar.mockInterfaces, "interfaces", "", "mock interfaces")
}

var tmplInterface = template.Must(template.New("").Parse(`
// Code generated by gsmock {{.ToolVersion}}. DO NOT EDIT.
// Source: https://github.com/go-spring/mock
// gsmock -o {{.ToolParams.Output}} -i '{{.ToolParams.Interfaces}}'

package {{.Package}}

import (
{{.Imports}}
)

{{ range $i := .Interfaces }}
{{- if gt (len $i.TypeParams) 0 }}
type {{$i.Name}}MockImpl[{{$i.TypeParams}}] struct {
	{{$i.EmbedInterfaces}}
	r *mock.Manager
}

func New{{$i.Name}}MockImpl[{{$i.TypeParams}}](r *mock.Manager) *{{$i.Name}}MockImpl[{{$i.TypeParamNames}}] {
	return &{{$i.Name}}MockImpl[{{$i.TypeParamNames}}]{r: r}
}
{{- else}}
type {{$i.Name}}MockImpl struct {
	{{$i.EmbedInterfaces}}
	r *mock.Manager
}

func New{{$i.Name}}MockImpl(r *mock.Manager) *{{$i.Name}}MockImpl {
	return &{{$i.Name}}MockImpl{r: r}
}
{{- end}}

{{range $m := $i.Methods}}
{{if gt (len $i.TypeParams) 0 }}
func (impl *{{$i.Name}}MockImpl[{{$i.TypeParamNames}}]) {{$m.Name}}({{$m.Params}})({{$m.ResultTypes}}){
	t := reflect.TypeFor[{{$i.Name}}MockImpl[{{$i.TypeParamNames}}]]()
	if ret, ok := mock.Invoke(impl.r, t, "{{$m.Name}}", {{$m.ParamNames}}); ok {
		return mock.Unbox{{$m.ResultCount}}[{{$m.ResultTypes}}](ret)
	}
	panic("no mock code matched")
}

func (impl *{{$i.Name}}MockImpl[{{$i.TypeParamNames}}]) Mock{{$m.Name}}() *mock.Mocker{{$m.ParamCount}}{{$m.ResultCount}}[{{$m.ParamTypes}}, {{$m.ResultTypes}}] {
	t := reflect.TypeFor[{{$i.Name}}MockImpl[{{$i.TypeParamNames}}]]()
	return mock.NewMocker{{$m.ParamCount}}{{$m.ResultCount}}[{{$m.ParamTypes}}, {{$m.ResultTypes}}](impl.r, t, "{{$m.Name}}")
}
{{- else}}
func (impl *{{$i.Name}}MockImpl) {{$m.Name}}({{$m.Params}})({{$m.ResultTypes}}){
	t := reflect.TypeFor[{{$i.Name}}MockImpl]()
	if ret, ok := mock.Invoke(impl.r, t, "{{$m.Name}}", {{$m.ParamNames}}); ok {
		return mock.Unbox{{$m.ResultCount}}[{{$m.ResultTypes}}](ret)
	}
	panic("no mock code matched")
}

func (impl *{{$i.Name}}MockImpl) Mock{{$m.Name}}() *mock.Mocker{{$m.ParamCount}}{{$m.ResultCount}}[{{$m.ParamTypes}}, {{$m.ResultTypes}}] {
	t := reflect.TypeFor[{{$i.Name}}MockImpl]()
	return mock.NewMocker{{$m.ParamCount}}{{$m.ResultCount}}[{{$m.ParamTypes}}, {{$m.ResultTypes}}](impl.r, t, "{{$m.Name}}")
}
{{- end}}
{{- end}}
{{- end}}
`))

func main() {
	flag.Parse()
	run(runParam{
		sourceDir:      ".",
		outputFile:     flagVar.outputFile,
		mockInterfaces: flagVar.mockInterfaces,
	})
}

type runParam struct {
	sourceDir      string
	outputFile     string
	mockInterfaces string
}

func run(param runParam) {
	ctx := scanContext{
		outputFile:        param.outputFile,
		includeInterfaces: make(map[string]struct{}),
		excludeInterfaces: make(map[string]struct{}),
	}

	ctx.parse(param.mockInterfaces)

	// pkgPath => pkgName
	pkgs := make(map[string]string)
	interfaces := scanDir(param.sourceDir, ctx, pkgs)

	imports := make(map[string]string)
	imports["reflect"] = "reflect"
	imports["mock"] = "github.com/go-spring/mock"
	for _, m := range interfaces {
		for pkgName, pkgPath := range m.Imports {
			imports[pkgName] = pkgPath
		}
	}

	var h bytes.Buffer
	for pkgName, pkgPath := range imports {
		ss := strings.Split(pkgPath, "/")
		if pkgName == ss[len(ss)-1] {
			h.WriteString(fmt.Sprintf("\t\"%s\"\n", pkgPath))
		} else {
			h.WriteString(fmt.Sprintf("\t%s \"%s\"\n", pkgName, pkgPath))
		}
	}

	toolParams := map[string]any{
		"Output":     param.outputFile,
		"Interfaces": param.mockInterfaces,
	}

	s := bytes.NewBuffer(nil)
	err := tmplInterface.Execute(s, map[string]any{
		"ToolVersion": ToolVersion,
		"ToolParams":  toolParams,
		"Package":     interfaces[0].PackageName,
		"Imports":     h.String(),
		"Interfaces":  interfaces,
	})
	if err != nil {
		panic(err)
	}

	b, err := format.Source(s.Bytes())
	if err != nil {
		panic(err)
	}

	if param.outputFile == "" {
		if _, err = os.Stdout.Write(b); err != nil {
			panic(err)
		}
		return
	}

	outputFile := filepath.Join(param.sourceDir, param.outputFile)
	err = os.WriteFile(outputFile, b, os.ModePerm)
	if err != nil {
		panic(err)
	}
}

type scanContext struct {
	outputFile        string
	includeInterfaces map[string]struct{}
	excludeInterfaces map[string]struct{}
}

func (ctx *scanContext) parse(mockInterfaces string) {
	if c := mockInterfaces[0]; c == '\'' || c == '"' {
		mockInterfaces = mockInterfaces[1 : len(mockInterfaces)-1]
	}
	ss := strings.Split(mockInterfaces, ",")
	for _, s := range ss {
		if len(s) == 0 {
			continue
		}
		if s[0] == '!' {
			ctx.excludeInterfaces[s[1:]] = struct{}{}
		} else {
			ctx.includeInterfaces[s] = struct{}{}
		}
	}
}

func (ctx *scanContext) mock(name string) bool {
	if len(ctx.includeInterfaces) > 0 {
		_, ok := ctx.includeInterfaces[name]
		return ok
	}
	_, ok := ctx.excludeInterfaces[name]
	return !ok
}

// Interface is the interface to be mocked.
type Interface struct {
	PackageName     string
	Name            string
	TypeParams      string
	TypeParamNames  string
	EmbedInterfaces string
	Methods         []Method
	File            string
	Imports         map[string]string
}

type Method struct {
	Name        string
	Params      string
	ParamNames  string
	ParamTypes  string
	ParamCount  int
	ResultTypes string
	ResultCount int
}

func scanDir(dir string, ctx scanContext, pkgs map[string]string) []Interface {
	entries, err := os.ReadDir(dir)
	if err != nil {
		panic(err)
	}
	var ret []Interface
	for _, entry := range entries {
		if entry.IsDir() {
			continue
		}
		if entry.Name() == ctx.outputFile {
			continue
		}
		if strings.HasSuffix(entry.Name(), "_test.go") {
			continue
		}
		arr := scanFile(ctx, filepath.Join(dir, entry.Name()), pkgs)
		ret = append(ret, arr...)
	}
	return ret
}

func scanFile(ctx scanContext, file string, pkgs map[string]string) []Interface {
	mode := parser.AllErrors
	node, err := parser.ParseFile(token.NewFileSet(), file, nil, mode)
	if err != nil {
		panic(err)
	}

	var (
		needImports  = make(map[string]string)
		totalImports = make(map[string]string)
	)
	for _, spec := range node.Imports {
		pkgPath := spec.Path.Value
		pkgPath = pkgPath[1 : len(pkgPath)-1]

		var pkgName string
		if spec.Name != nil {
			pkgName = spec.Name.Name
		} else {
			ss := strings.Split(pkgPath, "/")
			pkgName = ss[len(ss)-1]
		}

		if v, ok := pkgs[pkgPath]; ok {
			if v != pkgName {
				panic(fmt.Sprintf("import package name conflict: %s, %s", v, pkgName))
			}
		} else {
			pkgs[pkgPath] = pkgName
		}

		totalImports[pkgName] = pkgPath
	}

	putImport := func(pkgNames []string) {
		for _, s := range pkgNames {
			pkgName := s[:len(s)-1]
			pkgPath, ok := totalImports[pkgName]
			if ok {
				needImports[pkgName] = pkgPath
			}
		}
	}

	var ret []Interface
	for _, decl := range node.Decls {
		d, ok := decl.(*ast.GenDecl)
		if !ok || d.Tok != token.TYPE {
			continue
		}

		for _, spec := range d.Specs {
			s := spec.(*ast.TypeSpec)
			t, ok := s.Type.(*ast.InterfaceType)
			if !ok || len(t.Methods.List) == 0 {
				continue
			}

			name := s.Name.String()
			if !ctx.mock(name) {
				continue
			}

			var (
				typeParams     []string
				typeParamNames []string
			)
			if s.TypeParams != nil {
				for _, f := range s.TypeParams.List {
					fName := f.Names[0].Name
					typeText, pkgNames := getTypeText(f.Type)
					typeParams = append(typeParams, fName+" "+typeText)
					typeParamNames = append(typeParamNames, fName)
					putImport(pkgNames)
				}
			}

			var embedInterfaces string
			for _, method := range t.Methods.List {
				if len(method.Names) == 0 {
					embedInterfaces += "\t"
					typeText, pkgNames := getTypeText(method.Type)
					embedInterfaces += typeText
					embedInterfaces += "\n"
					putImport(pkgNames)
				}
			}

			var methods []Method
			for _, method := range t.Methods.List {
				if len(method.Names) == 0 {
					continue
				}
				ft := method.Type.(*ast.FuncType)
				methodName := method.Names[0].Name

				var (
					paramCount  int
					resultCount int
				)

				if ft.Params != nil {
					paramCount = len(ft.Params.List)
				}
				if paramCount == 0 {
					panic(fmt.Sprintf("method %s has no parameters", methodName))
				} else if paramCount > mock.MaxParamCount {
					panic(fmt.Sprintf("have more than %d parameters", mock.MaxParamCount))
				}

				if ft.Results != nil {
					resultCount = len(ft.Results.List)
				}
				if resultCount == 0 {
					panic(fmt.Sprintf("method %s has no results", methodName))
				} else if resultCount > mock.MaxResultCount {
					panic(fmt.Sprintf("have more than %d results", mock.MaxResultCount))
				}

				var (
					params     []string
					paramNames []string
					paramTypes []string
				)
				if ft.Params != nil {
					for _, param := range ft.Params.List {
						typeText, pkgNames := getTypeText(param.Type)
						paramTypes = append(paramTypes, typeText)
						if len(param.Names) == 0 {
							panic("param name is empty")
						}
						paramName := param.Names[0].Name
						paramNames = append(paramNames, paramName)
						params = append(params, paramName+" "+typeText)
						putImport(pkgNames)
					}
				}

				var (
					resultTypes []string
				)
				if ft.Results != nil {
					for _, result := range ft.Results.List {
						typeText, pkgNames := getTypeText(result.Type)
						resultTypes = append(resultTypes, typeText)
						putImport(pkgNames)
					}
				}

				methods = append(methods, Method{
					Name:        methodName,
					Params:      strings.Join(params, ", "),
					ParamNames:  strings.Join(paramNames, ", "),
					ParamTypes:  strings.Join(paramTypes, ", "),
					ResultTypes: strings.Join(resultTypes, ", "),
					ParamCount:  paramCount,
					ResultCount: resultCount,
				})
			}

			ret = append(ret, Interface{
				PackageName:     node.Name.String(),
				Name:            name,
				TypeParams:      strings.Join(typeParams, ", "),
				TypeParamNames:  strings.Join(typeParamNames, ", "),
				EmbedInterfaces: embedInterfaces,
				Methods:         methods,
				File:            file,
				Imports:         needImports,
			})
		}
	}
	return ret
}

var (
	typeTextBuffer  bytes.Buffer
	typeTextFileSet = token.NewFileSet()
	pkgNameSelector = regexp.MustCompile(`([a-zA-Z0-9_]+\.)`)
)

// getTypeText returns the text representation of the given type.
func getTypeText(t ast.Expr) (typeText string, pkgNames []string) {
	typeTextBuffer.Reset()
	_ = printer.Fprint(&typeTextBuffer, typeTextFileSet, t)
	typeText = typeTextBuffer.String()
	pkgNames = pkgNameSelector.FindAllString(typeText, -1)
	return
}
