/*
 * Copyright 2025 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package main

import (
	"text/template"
)

// tmplFileHeader defines the header template for the generated Go file.
var tmplFileHeader = template.Must(template.New("FileHeader").Parse(`
// Code generated by gs-mock {{.ToolVersion}}. DO NOT EDIT.
// Source: https://github.com/go-spring/gs-mock
// gs mock {{.ToolCommand}}

package {{.Package}}

import (
{{.Imports}}
)`))

// tmplInterface defines the template for generating a mock implementation
// of an interface. It supports both generic and non-generic interfaces.
var tmplInterface = template.Must(template.New("Interface").Parse(`
{{if gt (len .TypeParams) 0 }}
	// {{.Name}}MockImpl is a generated mock implementation of the {{.Name}} interface
	// with type parameters [{{.TypeParams}}].
	type {{.Name}}MockImpl[{{.TypeParams}}] struct {
		{{.EmbedInterfaces}}
		r *gsmock.Manager
	}
	
	// New{{.Name}}MockImpl creates a new mock instance for {{.Name}} with the given
	// gsmock.Manager and initializes the embedded interfaces.
	func New{{.Name}}MockImpl[{{.TypeParams}}](r *gsmock.Manager) *{{.Name}}MockImpl[{{.TypeParamNames}}] {
		return &{{.Name}}MockImpl[{{.TypeParamNames}}]{r: r}
	}
{{- else}}
	// {{.Name}}MockImpl is a generated mock implementation of the {{.Name}} interface.
	// It embeds the original interfaces and provides methods to register mock behaviors.
	type {{.Name}}MockImpl struct {
		{{.EmbedInterfaces}}
		r *gsmock.Manager
	}
	
	// New{{.Name}}MockImpl creates a new mock instance for {{.Name}} with the given
	// gsmock.Manager and initializes the embedded interfaces.
	func New{{.Name}}MockImpl(r *gsmock.Manager) *{{.Name}}MockImpl {
		return &{{.Name}}MockImpl{r: r}
	}
{{- end}}
`))

// getMethodTemplate selects the correct method template based on the
// number of return values for the method.
func getMethodTemplate(resultCount int) *template.Template {
	if resultCount == 0 {
		return tmplMethodN0
	}
	return tmplMethodNN
}

// tmplMethodN0 defines a template for methods with N parameters and no return values.
// It generates the method implementation and a corresponding MockXXX() registration method.
var tmplMethodN0 = template.Must(template.New("MethodN0").Parse(`
{{if gt (len .i.TypeParams) 0 }}
	//go:noinline
	func (impl *{{.i.Name}}MockImpl[{{.i.TypeParamNames}}]) func{{.m.Name}}() func(impl *{{.i.Name}}MockImpl[{{.i.TypeParamNames}}], {{.m.Params}}){
		return (*{{.i.Name}}MockImpl[{{.i.TypeParamNames}}]).{{.m.Name}}
	}
	
	// {{.m.Name}} executes the mocked {{.m.Name}} method.
	func (impl *{{.i.Name}}MockImpl[{{.i.TypeParamNames}}]) {{.m.Name}}({{.m.Params}}){
		if _, ok := gsmock.Invoke(impl.r, impl.func{{.m.Name}}(), impl, {{.m.ParamNames}}); ok {
			return
		}
		panic("no mock code matched for {{.i.Name}}MockImpl.{{.m.Name}}")
	}
	
	// Mock{{.m.Name}} returns a {{.m.Var}}Mocker{{.m.ParamCount}}0 instance to register mock behavior for {{.m.Name}}.
	func (impl *{{.i.Name}}MockImpl[{{.i.TypeParamNames}}]) Mock{{.m.Name}}() *gsmock.{{.m.Var}}Mocker{{.m.ParamCount}}0[*{{.i.Name}}MockImpl[{{.i.TypeParamNames}}], {{.m.ParamTypes}}] {
		return gsmock.{{.m.Var}}Mock{{.m.ParamCount}}0(impl.func{{.m.Name}}(), impl.r)
	}
{{- else}}
	//go:noinline
	func (impl *{{.i.Name}}MockImpl) func{{.m.Name}}() func(impl *{{.i.Name}}MockImpl, {{.m.Params}}){
		return (*{{.i.Name}}MockImpl).{{.m.Name}}
	}
	
	// {{.m.Name}} executes the mocked {{.m.Name}} method.
	func (impl *{{.i.Name}}MockImpl) {{.m.Name}}({{.m.Params}}){
		if _, ok := gsmock.Invoke(impl.r, impl.func{{.m.Name}}(), impl, {{.m.ParamNames}}); ok {
			return
		}
		panic("no mock code matched for {{.i.Name}}MockImpl.{{.m.Name}}")
	}
	
	// Mock{{.m.Name}} returns a {{.m.Var}}Mocker{{.m.ParamCount}}0 instance to register mock behavior for {{.m.Name}}.
	func (impl *{{.i.Name}}MockImpl) Mock{{.m.Name}}() *gsmock.{{.m.Var}}Mocker{{.m.ParamCount}}0[*{{.i.Name}}MockImpl, {{.m.ParamTypes}}] {
		return gsmock.{{.m.Var}}Mock{{.m.ParamCount}}0(impl.func{{.m.Name}}(), impl.r)
	}
	{{- end}}
`))

// tmplMethodNN defines a template for methods with N parameters and N return values.
// It generates the method implementation and a corresponding MockXXX() registration method.
var tmplMethodNN = template.Must(template.New("MethodNN").Parse(`
{{if gt (len .i.TypeParams) 0 }}
	//go:noinline
	func (impl *{{.i.Name}}MockImpl[{{.i.TypeParamNames}}]) func{{.m.Name}}() func(impl *{{.i.Name}}MockImpl[{{.i.TypeParamNames}}], {{.m.Params}})({{.m.ResultTypes}}){
		return (*{{.i.Name}}MockImpl[{{.i.TypeParamNames}}]).{{.m.Name}}
	}
	
	// {{.m.Name}} executes the mocked {{.m.Name}} method.
	func (impl *{{.i.Name}}MockImpl[{{.i.TypeParamNames}}]) {{.m.Name}}({{.m.Params}})({{.m.ResultTypes}}){
		if ret, ok := gsmock.Invoke(impl.r, impl.func{{.m.Name}}(), impl, {{.m.ParamNames}}); ok {
			return gsmock.Unbox{{.m.ResultCount}}[{{.m.ResultTypes}}](ret)
		}
		panic("no mock code matched for {{.i.Name}}MockImpl.{{.m.Name}}")
	}
	
	// Mock{{.m.Name}} returns a {{.m.Var}}Mocker{{.m.ParamCount}}{{.m.ResultCount}} instance to register mock behavior for {{.m.Name}}.
	func (impl *{{.i.Name}}MockImpl[{{.i.TypeParamNames}}]) Mock{{.m.Name}}() *gsmock.{{.m.Var}}Mocker{{.m.ParamCount}}{{.m.ResultCount}}[*{{.i.Name}}MockImpl[{{.i.TypeParamNames}}], {{.m.ParamTypes}} {{.m.ResultTypes}}] {
		return gsmock.{{.m.Var}}Mock{{.m.ParamCount}}{{.m.ResultCount}}(impl.func{{.m.Name}}(), impl.r)
	}
{{- else}}
	//go:noinline
	func (impl *{{.i.Name}}MockImpl) func{{.m.Name}}() func(impl *{{.i.Name}}MockImpl, {{.m.Params}})({{.m.ResultTypes}}){
		return (*{{.i.Name}}MockImpl).{{.m.Name}}
	}
	
	// {{.m.Name}} executes the mocked {{.m.Name}} method.
	func (impl *{{.i.Name}}MockImpl) {{.m.Name}}({{.m.Params}})({{.m.ResultTypes}}){
		if ret, ok := gsmock.Invoke(impl.r, impl.func{{.m.Name}}(), impl, {{.m.ParamNames}}); ok {
			return gsmock.Unbox{{.m.ResultCount}}[{{.m.ResultTypes}}](ret)
		}
		panic("no mock code matched for {{.i.Name}}MockImpl.{{.m.Name}}")
	}
	
	// Mock{{.m.Name}} returns a {{.m.Var}}Mocker{{.m.ParamCount}}{{.m.ResultCount}} instance to register mock behavior for {{.m.Name}}.
	func (impl *{{.i.Name}}MockImpl) Mock{{.m.Name}}() *gsmock.{{.m.Var}}Mocker{{.m.ParamCount}}{{.m.ResultCount}}[*{{.i.Name}}MockImpl, {{.m.ParamTypes}} {{.m.ResultTypes}}] {
		return gsmock.{{.m.Var}}Mock{{.m.ParamCount}}{{.m.ResultCount}}(impl.func{{.m.Name}}(), impl.r)
	}
{{- end}}
`))
