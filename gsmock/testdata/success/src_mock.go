// Code generated by gsmock v0.0.1. DO NOT EDIT.
// Source: https://github.com/go-spring/mock
// gsmock -o src_mock.go -i '!RepositoryV2'

package success

import (
	"context"
	"io"
	"net/http"
	"reflect"

	"github.com/go-spring/mock"
	"github.com/go-spring/mock/gsmock/testdata/success/inner"
)

type RepositoryMockImpl[T ~int | ~uint, M *http.Request] struct {
	r *mock.Manager
}

func NewRepositoryMockImpl[T ~int | ~uint, M *http.Request](r *mock.Manager) *RepositoryMockImpl[T, M] {
	return &RepositoryMockImpl[T, M]{r: r}
}

func (impl *RepositoryMockImpl[T, M]) FindByID(id string) (T, error) {
	t := reflect.TypeFor[RepositoryMockImpl[T, M]]()
	if ret, ok := mock.Invoke(impl.r, t, "FindByID", id); ok {
		return mock.Unbox2[T, error](ret)
	}
	panic("no mock code matched")
}

func (impl *RepositoryMockImpl[T, M]) MockFindByID() *mock.Mocker12[string, T, error] {
	t := reflect.TypeFor[RepositoryMockImpl[T, M]]()
	return mock.NewMocker12[string, T, error](impl.r, t, "FindByID")
}

func (impl *RepositoryMockImpl[T, M]) Save(item T) error {
	t := reflect.TypeFor[RepositoryMockImpl[T, M]]()
	if ret, ok := mock.Invoke(impl.r, t, "Save", item); ok {
		return mock.Unbox1[error](ret)
	}
	panic("no mock code matched")
}

func (impl *RepositoryMockImpl[T, M]) MockSave() *mock.Mocker11[T, error] {
	t := reflect.TypeFor[RepositoryMockImpl[T, M]]()
	return mock.NewMocker11[T, error](impl.r, t, "Save")
}

type GenericServiceMockImpl[T any, R any] struct {
	io.Writer

	r *mock.Manager
}

func NewGenericServiceMockImpl[T any, R any](r *mock.Manager) *GenericServiceMockImpl[T, R] {
	return &GenericServiceMockImpl[T, R]{r: r}
}

func (impl *GenericServiceMockImpl[T, R]) M00() {
	t := reflect.TypeFor[GenericServiceMockImpl[T, R]]()
	if _, ok := mock.Invoke(impl.r, t, "M00"); ok {
		return
	}
	panic("no mock code matched")
}

func (impl *GenericServiceMockImpl[T, R]) MockM00() *mock.Mocker00 {
	t := reflect.TypeFor[GenericServiceMockImpl[T, R]]()
	return mock.NewMocker00(impl.r, t, "M00")
}

func (impl *GenericServiceMockImpl[T, R]) M01() R {
	t := reflect.TypeFor[GenericServiceMockImpl[T, R]]()
	if ret, ok := mock.Invoke(impl.r, t, "M01"); ok {
		return mock.Unbox1[R](ret)
	}
	panic("no mock code matched")
}

func (impl *GenericServiceMockImpl[T, R]) MockM01() *mock.Mocker01[R] {
	t := reflect.TypeFor[GenericServiceMockImpl[T, R]]()
	return mock.NewMocker01[R](impl.r, t, "M01")
}

func (impl *GenericServiceMockImpl[T, R]) M10(r0 T) {
	t := reflect.TypeFor[GenericServiceMockImpl[T, R]]()
	if _, ok := mock.Invoke(impl.r, t, "M10", r0); ok {
		return
	}
	panic("no mock code matched")
}

func (impl *GenericServiceMockImpl[T, R]) MockM10() *mock.Mocker10[T] {
	t := reflect.TypeFor[GenericServiceMockImpl[T, R]]()
	return mock.NewMocker10[T](impl.r, t, "M10")
}

func (impl *GenericServiceMockImpl[T, R]) M11(r0 T) R {
	t := reflect.TypeFor[GenericServiceMockImpl[T, R]]()
	if ret, ok := mock.Invoke(impl.r, t, "M11", r0); ok {
		return mock.Unbox1[R](ret)
	}
	panic("no mock code matched")
}

func (impl *GenericServiceMockImpl[T, R]) MockM11() *mock.Mocker11[T, R] {
	t := reflect.TypeFor[GenericServiceMockImpl[T, R]]()
	return mock.NewMocker11[T, R](impl.r, t, "M11")
}

func (impl *GenericServiceMockImpl[T, R]) M02() (R, bool) {
	t := reflect.TypeFor[GenericServiceMockImpl[T, R]]()
	if ret, ok := mock.Invoke(impl.r, t, "M02"); ok {
		return mock.Unbox2[R, bool](ret)
	}
	panic("no mock code matched")
}

func (impl *GenericServiceMockImpl[T, R]) MockM02() *mock.Mocker02[R, bool] {
	t := reflect.TypeFor[GenericServiceMockImpl[T, R]]()
	return mock.NewMocker02[R, bool](impl.r, t, "M02")
}

func (impl *GenericServiceMockImpl[T, R]) M12(r0 T) (R, bool) {
	t := reflect.TypeFor[GenericServiceMockImpl[T, R]]()
	if ret, ok := mock.Invoke(impl.r, t, "M12", r0); ok {
		return mock.Unbox2[R, bool](ret)
	}
	panic("no mock code matched")
}

func (impl *GenericServiceMockImpl[T, R]) MockM12() *mock.Mocker12[T, R, bool] {
	t := reflect.TypeFor[GenericServiceMockImpl[T, R]]()
	return mock.NewMocker12[T, R, bool](impl.r, t, "M12")
}

func (impl *GenericServiceMockImpl[T, R]) M22(ctx context.Context, req map[string]T) (*Response, bool) {
	t := reflect.TypeFor[GenericServiceMockImpl[T, R]]()
	if ret, ok := mock.Invoke(impl.r, t, "M22", ctx, req); ok {
		return mock.Unbox2[*Response, bool](ret)
	}
	panic("no mock code matched")
}

func (impl *GenericServiceMockImpl[T, R]) MockM22() *mock.Mocker22[context.Context, map[string]T, *Response, bool] {
	t := reflect.TypeFor[GenericServiceMockImpl[T, R]]()
	return mock.NewMocker22[context.Context, map[string]T, *Response, bool](impl.r, t, "M22")
}

func (impl *GenericServiceMockImpl[T, R]) Printf(format string, args ...any) {
	t := reflect.TypeFor[GenericServiceMockImpl[T, R]]()
	if _, ok := mock.Invoke(impl.r, t, "Printf", format, args); ok {
		return
	}
	panic("no mock code matched")
}

func (impl *GenericServiceMockImpl[T, R]) MockPrintf() *mock.Mocker20[string, []any] {
	t := reflect.TypeFor[GenericServiceMockImpl[T, R]]()
	return mock.NewMocker20[string, []any](impl.r, t, "Printf")
}

type ServiceMockImpl struct {
	io.Writer

	r *mock.Manager
}

func NewServiceMockImpl(r *mock.Manager) *ServiceMockImpl {
	return &ServiceMockImpl{r: r}
}

func (impl *ServiceMockImpl) M00() {
	t := reflect.TypeFor[ServiceMockImpl]()
	if _, ok := mock.Invoke(impl.r, t, "M00"); ok {
		return
	}
	panic("no mock code matched")
}

func (impl *ServiceMockImpl) MockM00() *mock.Mocker00 {
	t := reflect.TypeFor[ServiceMockImpl]()
	return mock.NewMocker00(impl.r, t, "M00")
}

func (impl *ServiceMockImpl) M01() *Response {
	t := reflect.TypeFor[ServiceMockImpl]()
	if ret, ok := mock.Invoke(impl.r, t, "M01"); ok {
		return mock.Unbox1[*Response](ret)
	}
	panic("no mock code matched")
}

func (impl *ServiceMockImpl) MockM01() *mock.Mocker01[*Response] {
	t := reflect.TypeFor[ServiceMockImpl]()
	return mock.NewMocker01[*Response](impl.r, t, "M01")
}

func (impl *ServiceMockImpl) M10(r0 *inner.Request) {
	t := reflect.TypeFor[ServiceMockImpl]()
	if _, ok := mock.Invoke(impl.r, t, "M10", r0); ok {
		return
	}
	panic("no mock code matched")
}

func (impl *ServiceMockImpl) MockM10() *mock.Mocker10[*inner.Request] {
	t := reflect.TypeFor[ServiceMockImpl]()
	return mock.NewMocker10[*inner.Request](impl.r, t, "M10")
}

func (impl *ServiceMockImpl) M11(r0 *inner.Request) *Response {
	t := reflect.TypeFor[ServiceMockImpl]()
	if ret, ok := mock.Invoke(impl.r, t, "M11", r0); ok {
		return mock.Unbox1[*Response](ret)
	}
	panic("no mock code matched")
}

func (impl *ServiceMockImpl) MockM11() *mock.Mocker11[*inner.Request, *Response] {
	t := reflect.TypeFor[ServiceMockImpl]()
	return mock.NewMocker11[*inner.Request, *Response](impl.r, t, "M11")
}

func (impl *ServiceMockImpl) M02() (*Response, bool) {
	t := reflect.TypeFor[ServiceMockImpl]()
	if ret, ok := mock.Invoke(impl.r, t, "M02"); ok {
		return mock.Unbox2[*Response, bool](ret)
	}
	panic("no mock code matched")
}

func (impl *ServiceMockImpl) MockM02() *mock.Mocker02[*Response, bool] {
	t := reflect.TypeFor[ServiceMockImpl]()
	return mock.NewMocker02[*Response, bool](impl.r, t, "M02")
}

func (impl *ServiceMockImpl) M12(r0 *inner.Request) (*Response, bool) {
	t := reflect.TypeFor[ServiceMockImpl]()
	if ret, ok := mock.Invoke(impl.r, t, "M12", r0); ok {
		return mock.Unbox2[*Response, bool](ret)
	}
	panic("no mock code matched")
}

func (impl *ServiceMockImpl) MockM12() *mock.Mocker12[*inner.Request, *Response, bool] {
	t := reflect.TypeFor[ServiceMockImpl]()
	return mock.NewMocker12[*inner.Request, *Response, bool](impl.r, t, "M12")
}

func (impl *ServiceMockImpl) M22(ctx context.Context, req map[string]*inner.Request) (*Response, bool) {
	t := reflect.TypeFor[ServiceMockImpl]()
	if ret, ok := mock.Invoke(impl.r, t, "M22", ctx, req); ok {
		return mock.Unbox2[*Response, bool](ret)
	}
	panic("no mock code matched")
}

func (impl *ServiceMockImpl) MockM22() *mock.Mocker22[context.Context, map[string]*inner.Request, *Response, bool] {
	t := reflect.TypeFor[ServiceMockImpl]()
	return mock.NewMocker22[context.Context, map[string]*inner.Request, *Response, bool](impl.r, t, "M22")
}

func (impl *ServiceMockImpl) Printf(format string, args ...any) {
	t := reflect.TypeFor[ServiceMockImpl]()
	if _, ok := mock.Invoke(impl.r, t, "Printf", format, args); ok {
		return
	}
	panic("no mock code matched")
}

func (impl *ServiceMockImpl) MockPrintf() *mock.Mocker20[string, []any] {
	t := reflect.TypeFor[ServiceMockImpl]()
	return mock.NewMocker20[string, []any](impl.r, t, "Printf")
}
