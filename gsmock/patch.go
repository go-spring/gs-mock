/*
 * Copyright 2025 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package gsmock

import (
	"context"
	"reflect"
	"sync"

	"github.com/bytedance/mockey"
)

var (
	patchMux    sync.Mutex
	patchFuncs  = make(map[string]struct{})
	contextType = reflect.TypeFor[context.Context]()
)

// OriginHolder stores the original (unpatched) function
// so it can be called after patching.
type OriginHolder[T any] struct {
	Origin T
}

// PatchOnce applies a mock interception layer to function f only once.
//
// ### Key Constraints
//   - T must be a *top-level function* or a method with a *receiver type*.
//     Instance methods bound to a specific value are not supported.
//   - The function must have `context.Context` as either its 1st or 2nd parameter.
//     This is required because mocking works by propagating the mock manager
//     through the ctx object.
//   - If a function is already patched, it will not be patched again.
//
// ### Behavior
// PatchOnce installs a wrapper function generated by PatchFunc().
// The wrapper extracts a context from the first two params and attempts
// to dispatch the call through InvokeContext().
// If no mock handles the call, the wrapper calls the original function.
func PatchOnce[T any](f T) {

	// Patch only if the function has at least one argument
	// and its first or second argument is context.Context.
	if t := reflect.TypeOf(f); t.NumIn() == 0 {
		return
	} else if t.In(0) != contextType {
		if t.NumIn() == 1 || t.In(1) != contextType {
			return
		}
	}

	patchMux.Lock()
	defer patchMux.Unlock()

	k := GetFuncID(f)
	if _, ok := patchFuncs[k]; ok {
		return
	}

	var o OriginHolder[T]

	mockey.Mock(f).
		Origin(&o.Origin).
		To(PatchFunc(f, &o)).
		Build()

	patchFuncs[k] = struct{}{}
}

// PatchFunc generates a wrapper function for f.
// The wrapper attempts to intercept calls using InvokeContext()
// when a context.Context is found among the arguments.
// If interception does not apply, it falls back to calling the original function.
func PatchFunc[T any](f T, o *OriginHolder[T]) T {
	t := reflect.TypeOf(f)
	return reflect.MakeFunc(t, func(args []reflect.Value) []reflect.Value {
		if n := len(args); n > 0 {
			params := make([]any, n)
			for i, v := range args {
				params[i] = v.Interface()
			}

			// Try extracting context from the first two parameters.
			ctx, ok := params[0].(context.Context)
			if !ok && n > 1 {
				ctx, ok = params[1].(context.Context)
			}

			// If context found, attempt context-bound invocation.
			if ok {
				if ret, ok := InvokeContext(ctx, f, params...); ok {
					out := make([]reflect.Value, len(ret))
					for i, v := range ret {
						if v == nil {
							out[i] = reflect.Zero(t.Out(i))
						} else {
							out[i] = reflect.ValueOf(v)
						}
					}
					return out
				}
			}
		}

		// Default behavior: call the original function.
		return reflect.ValueOf(o.Origin).Call(args)
	}).Interface().(T)
}
